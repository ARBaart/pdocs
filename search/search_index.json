{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Read Latest Documentation - Browse GitHub Code Repository pdocs is a library and a command line program to discover the public interface of a Python module or package. The pdocs script can be used to generate Markdown or HTML of a module's public interface, or it can be used to run an HTTP server that serves generated HTML for installed modules. pdocs is an MIT Licensed fork of pdoc 's original implementation by Andrew Gallant ( @BurntSushi ). with the goal of staying true to the original vision layed out by the project's creator. NOTE: For most projects, the best way to use pdocs is using portray . Features Support for documenting data representation by traversing the abstract syntax to find docstrings for module, class and instance variables. For cases where docstrings aren't appropriate (like a namedtuple ), the special variable __pdocs__ can be used in your module to document any identifier in your public interface. Usage is simple. Just write your documentation as Markdown. There are no added special syntax rules. pdocs respects your __all__ variable when present. pdocs will automatically link identifiers in your docstrings to its corresponding documentation. When pdocs is run as an HTTP server, external linking is supported between packages. The pdocs HTTP server will cache generated documentation and automatically regenerate it if the source code has been updated. When available, source code for modules, functions and classes can be viewed in the HTML documentation. Inheritance is used when possible to infer docstrings for class members. The above features are explained in more detail in pdocs's documentation. pdocs is compatible with Python 3.6 and newer. Quick Start The following guides should get you up using pdocs in no time: Installation - TL;DR: Run pip3 install pdocs within your projects virtual environment. Command Line Usage - TL;DR: Run pdocs server YOUR_MODULES to test and pdocs as_html YOUR_MODULES to generate HTML. API Usage - TL;DR: Everything available via the CLI is also easily available programmatically from within Python. Differences Between pdocs and pdoc Below is a running list of intentional differences between pdoc and pdocs : pdocs has built-in support for Markdown documentation generation (as needed by portray ). pdocs has built-in support for the inclusion of Type Annotation information in reference documentation. pdocs requires Python 3.6+; pdoc maintains Python2 compatibility as of the latest public release. pdocs uses the most recent development tools to ensure long-term maintainability (mypy, black, isort, flake8, bandit, ...) pdocs generates project documentation to a temporary folder when serving locally, instead of including a live server. An intentional trade-off between simplicity and performance. pdocs provides a simplified Python API in addition to CLI API. pdocs is actively maintained. pdocs uses hug CLI and sub-commands , pdoc uses argparse and a single command . pdoc provides textual documentation from the command-line, pdocs removed this feature for API simplicity. Notes on Licensing and Fork The original pdoc followed the Unlicense license , and as such so does the initial commit to this fork here . Unlicense is fully compatible with MIT, and the reason for the switch going forward is because MIT is a more standard and well-known license. As seen by that commit, I chose to fork with fresh history, as the project is very old (2013) and I felt many of the commits that happened in the past might, instead of helping to debug issues, lead to red herrings due to the many changes that have happened in the Python eco-system since that time. If you desire to see the complete history for any reason, it remains available on the original pdoc repository . Why Create pdocs ? I created pdocs to help power portray while staying true to the original vision of pdoc and maintain MIT license compatibility. In the end I created it to help power better documentation websites for Python projects. I hope you, too, find pdocs useful! ~Timothy Crosley","title":"Home"},{"location":"#features","text":"Support for documenting data representation by traversing the abstract syntax to find docstrings for module, class and instance variables. For cases where docstrings aren't appropriate (like a namedtuple ), the special variable __pdocs__ can be used in your module to document any identifier in your public interface. Usage is simple. Just write your documentation as Markdown. There are no added special syntax rules. pdocs respects your __all__ variable when present. pdocs will automatically link identifiers in your docstrings to its corresponding documentation. When pdocs is run as an HTTP server, external linking is supported between packages. The pdocs HTTP server will cache generated documentation and automatically regenerate it if the source code has been updated. When available, source code for modules, functions and classes can be viewed in the HTML documentation. Inheritance is used when possible to infer docstrings for class members. The above features are explained in more detail in pdocs's documentation. pdocs is compatible with Python 3.6 and newer.","title":"Features"},{"location":"#quick-start","text":"The following guides should get you up using pdocs in no time: Installation - TL;DR: Run pip3 install pdocs within your projects virtual environment. Command Line Usage - TL;DR: Run pdocs server YOUR_MODULES to test and pdocs as_html YOUR_MODULES to generate HTML. API Usage - TL;DR: Everything available via the CLI is also easily available programmatically from within Python.","title":"Quick Start"},{"location":"#differences-between-pdocs-and-pdoc","text":"Below is a running list of intentional differences between pdoc and pdocs : pdocs has built-in support for Markdown documentation generation (as needed by portray ). pdocs has built-in support for the inclusion of Type Annotation information in reference documentation. pdocs requires Python 3.6+; pdoc maintains Python2 compatibility as of the latest public release. pdocs uses the most recent development tools to ensure long-term maintainability (mypy, black, isort, flake8, bandit, ...) pdocs generates project documentation to a temporary folder when serving locally, instead of including a live server. An intentional trade-off between simplicity and performance. pdocs provides a simplified Python API in addition to CLI API. pdocs is actively maintained. pdocs uses hug CLI and sub-commands , pdoc uses argparse and a single command . pdoc provides textual documentation from the command-line, pdocs removed this feature for API simplicity.","title":"Differences Between pdocs and pdoc"},{"location":"#notes-on-licensing-and-fork","text":"The original pdoc followed the Unlicense license , and as such so does the initial commit to this fork here . Unlicense is fully compatible with MIT, and the reason for the switch going forward is because MIT is a more standard and well-known license. As seen by that commit, I chose to fork with fresh history, as the project is very old (2013) and I felt many of the commits that happened in the past might, instead of helping to debug issues, lead to red herrings due to the many changes that have happened in the Python eco-system since that time. If you desire to see the complete history for any reason, it remains available on the original pdoc repository .","title":"Notes on Licensing and Fork"},{"location":"#why-create-pdocs","text":"I created pdocs to help power portray while staying true to the original vision of pdoc and maintain MIT license compatibility. In the end I created it to help power better documentation websites for Python projects. I hope you, too, find pdocs useful! ~Timothy Crosley","title":"Why Create pdocs?"},{"location":"CHANGELOG/","text":"Install the latest To install the latest version of pdocs simply run: pip3 install pdocs OR poetry add pdocs OR pipenv install pdocs see the Installation QuickStart for more instructions. Changelog 1.0.1 - September 3rd 2019 Fixed a bug determining class methods 1.0.0 - September 2nd 2019 Initial API stable release of pdocs","title":"Changelog"},{"location":"CHANGELOG/#install-the-latest","text":"To install the latest version of pdocs simply run: pip3 install pdocs OR poetry add pdocs OR pipenv install pdocs see the Installation QuickStart for more instructions.","title":"Install the latest"},{"location":"CHANGELOG/#changelog","text":"","title":"Changelog"},{"location":"CHANGELOG/#101-september-3rd-2019","text":"Fixed a bug determining class methods","title":"1.0.1 - September 3rd 2019"},{"location":"CHANGELOG/#100-september-2nd-2019","text":"Initial API stable release of pdocs","title":"1.0.0 - September 2nd 2019"},{"location":"docs/contributing/1.-contributing-guide/","text":"Contributing to pdocs Looking for a useful open source project to contribute to? Want your contributions to be warmly welcomed and acknowledged? Welcome! You have found the right place. Getting pdocs set up for local development The first step when contributing to any project is getting it set up on your local machine. pdocs aims to make this as simple as possible. Account Requirements: A valid GitHub account Base System Requirements: Python3.6+ poetry bash or a bash compatible shell (should be auto-installed on Linux / Mac) Once you have verified that you system matches the base requirements you can start to get the project working by following these steps: Fork the project on GitHub . Clone your fork to your local file system: git clone https://github.com/$GITHUB_ACCOUNT/pdocs.git `cd pdocs poetry install Making a contribution Congrats! You're now ready to make a contribution! Use the following as a guide to help you reach a successful pull-request: Check the issues page on GitHub to see if the task you want to complete is listed there. If it's listed there, write a comment letting others know you are working on it. If it's not listed in GitHub issues, go ahead and log a new issue. Then add a comment letting everyone know you have it under control. If you're not sure if it's something that is good for the main pdocs project and want immediate feedback, you can discuss it here . Create an issue branch for your local work git checkout -b issue/$ISSUE-NUMBER . Do your magic here. Ensure your code matches the HOPE-8 Coding Standard used by the project. Submit a pull request to the main project repository via GitHub. Thanks for the contribution! It will quickly get reviewed, and, once accepted, will result in your name being added to the acknowledgments list :). Thank you! I can not tell you how thankful I am for the hard work done by pdocs contributors like you . Thank you! ~Timothy Crosley","title":"1. Contributing Guide"},{"location":"docs/contributing/1.-contributing-guide/#contributing-to-pdocs","text":"Looking for a useful open source project to contribute to? Want your contributions to be warmly welcomed and acknowledged? Welcome! You have found the right place.","title":"Contributing to pdocs"},{"location":"docs/contributing/1.-contributing-guide/#getting-pdocs-set-up-for-local-development","text":"The first step when contributing to any project is getting it set up on your local machine. pdocs aims to make this as simple as possible. Account Requirements: A valid GitHub account Base System Requirements: Python3.6+ poetry bash or a bash compatible shell (should be auto-installed on Linux / Mac) Once you have verified that you system matches the base requirements you can start to get the project working by following these steps: Fork the project on GitHub . Clone your fork to your local file system: git clone https://github.com/$GITHUB_ACCOUNT/pdocs.git `cd pdocs poetry install","title":"Getting pdocs set up for local development"},{"location":"docs/contributing/1.-contributing-guide/#making-a-contribution","text":"Congrats! You're now ready to make a contribution! Use the following as a guide to help you reach a successful pull-request: Check the issues page on GitHub to see if the task you want to complete is listed there. If it's listed there, write a comment letting others know you are working on it. If it's not listed in GitHub issues, go ahead and log a new issue. Then add a comment letting everyone know you have it under control. If you're not sure if it's something that is good for the main pdocs project and want immediate feedback, you can discuss it here . Create an issue branch for your local work git checkout -b issue/$ISSUE-NUMBER . Do your magic here. Ensure your code matches the HOPE-8 Coding Standard used by the project. Submit a pull request to the main project repository via GitHub. Thanks for the contribution! It will quickly get reviewed, and, once accepted, will result in your name being added to the acknowledgments list :).","title":"Making a contribution"},{"location":"docs/contributing/1.-contributing-guide/#thank-you","text":"I can not tell you how thankful I am for the hard work done by pdocs contributors like you . Thank you! ~Timothy Crosley","title":"Thank you!"},{"location":"docs/contributing/2.-coding-standard/","text":"HOPE 8 -- Style Guide for Hug Code HOPE: 8 Title: Style Guide for Hug Code Author(s): Timothy Crosley timothy.crosley@gmail.com Status: Active Type: Process Created: 19-May-2019 Updated: 17-August-2019 Introduction This document gives coding conventions for the Hug code comprising the Hug core as well as all official interfaces, extensions, and plugins for the framework. Optionally, projects that use Hug are encouraged to follow this HOPE and link to it as a reference. PEP 8 Foundation All guidelines in this document are in addition to those defined in Python's PEP 8 and PEP 257 guidelines. Line Length Too short of lines discourage descriptive variable names where they otherwise make sense. Too long of lines reduce overall readability and make it hard to compare 2 files side by side. There is no perfect number: but for Hug, we've decided to cap the lines at 100 characters. Descriptive Variable names Naming things is hard. Hug has a few strict guidelines on the usage of variable names, which hopefully will reduce some of the guesswork: - No one character variable names. - Except for x, y, and z as coordinates. - It's not okay to override built-in functions. - Except for id . Guido himself thought that shouldn't have been moved to the system module. It's too commonly used, and alternatives feel very artificial. - Avoid Acronyms, Abbreviations, or any other short forms - unless they are almost universally understand. Adding new modules New modules added to the a project that follows the HOPE-8 standard should all live directly within the base PROJECT_NAME/ directory without nesting. If the modules are meant only for internal use within the project, they should be prefixed with a leading underscore. For example, def _internal_function. Modules should contain a docstring at the top that gives a general explanation of the purpose and then restates the project's use of the MIT license. There should be a tests/test_$MODULE_NAME.py file created to correspond to every new module that contains test coverage for the module. Ideally, tests should be 1:1 (one test object per code object, one test method per code method) to the extent cleanly possible. Automated Code Cleaners All code submitted to Hug should be formatted using Black and isort. Black should be run with the line length set to 100, and isort with Black compatible settings in place. Automated Code Linting All code submitted to hug should run through the following tools: Black and isort verification. Flake8 flake8-bugbear Bandit pep8-naming vulture safety","title":"2. Coding Standard"},{"location":"docs/contributing/2.-coding-standard/#hope-8-style-guide-for-hug-code","text":"HOPE: 8 Title: Style Guide for Hug Code Author(s): Timothy Crosley timothy.crosley@gmail.com Status: Active Type: Process Created: 19-May-2019 Updated: 17-August-2019","title":"HOPE 8 -- Style Guide for Hug Code"},{"location":"docs/contributing/2.-coding-standard/#introduction","text":"This document gives coding conventions for the Hug code comprising the Hug core as well as all official interfaces, extensions, and plugins for the framework. Optionally, projects that use Hug are encouraged to follow this HOPE and link to it as a reference.","title":"Introduction"},{"location":"docs/contributing/2.-coding-standard/#pep-8-foundation","text":"All guidelines in this document are in addition to those defined in Python's PEP 8 and PEP 257 guidelines.","title":"PEP 8 Foundation"},{"location":"docs/contributing/2.-coding-standard/#line-length","text":"Too short of lines discourage descriptive variable names where they otherwise make sense. Too long of lines reduce overall readability and make it hard to compare 2 files side by side. There is no perfect number: but for Hug, we've decided to cap the lines at 100 characters.","title":"Line Length"},{"location":"docs/contributing/2.-coding-standard/#descriptive-variable-names","text":"Naming things is hard. Hug has a few strict guidelines on the usage of variable names, which hopefully will reduce some of the guesswork: - No one character variable names. - Except for x, y, and z as coordinates. - It's not okay to override built-in functions. - Except for id . Guido himself thought that shouldn't have been moved to the system module. It's too commonly used, and alternatives feel very artificial. - Avoid Acronyms, Abbreviations, or any other short forms - unless they are almost universally understand.","title":"Descriptive Variable names"},{"location":"docs/contributing/2.-coding-standard/#adding-new-modules","text":"New modules added to the a project that follows the HOPE-8 standard should all live directly within the base PROJECT_NAME/ directory without nesting. If the modules are meant only for internal use within the project, they should be prefixed with a leading underscore. For example, def _internal_function. Modules should contain a docstring at the top that gives a general explanation of the purpose and then restates the project's use of the MIT license. There should be a tests/test_$MODULE_NAME.py file created to correspond to every new module that contains test coverage for the module. Ideally, tests should be 1:1 (one test object per code object, one test method per code method) to the extent cleanly possible.","title":"Adding new modules"},{"location":"docs/contributing/2.-coding-standard/#automated-code-cleaners","text":"All code submitted to Hug should be formatted using Black and isort. Black should be run with the line length set to 100, and isort with Black compatible settings in place.","title":"Automated Code Cleaners"},{"location":"docs/contributing/2.-coding-standard/#automated-code-linting","text":"All code submitted to hug should run through the following tools: Black and isort verification. Flake8 flake8-bugbear Bandit pep8-naming vulture safety","title":"Automated Code Linting"},{"location":"docs/contributing/3.-code-of-conduct/","text":"HOPE 11 -- Code of Conduct HOPE: 11 Title: Code of Conduct Author(s): Timothy Crosley timothy.crosley@gmail.com Status: Active Type: Process Created: 17-August-2019 Updated: 17-August-2019 Abstract Defines the Code of Conduct for Hug and all related projects. Our Pledge In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting timothy.crosley@gmail.com . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. Confidentiality will be maintained with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution This Code of Conduct is adapted from the [Contributor Covenant][https://www.contributor-covenant.org], version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"3. Code Of Conduct"},{"location":"docs/contributing/3.-code-of-conduct/#hope-11-code-of-conduct","text":"HOPE: 11 Title: Code of Conduct Author(s): Timothy Crosley timothy.crosley@gmail.com Status: Active Type: Process Created: 17-August-2019 Updated: 17-August-2019","title":"HOPE 11 -- Code of Conduct"},{"location":"docs/contributing/3.-code-of-conduct/#abstract","text":"Defines the Code of Conduct for Hug and all related projects.","title":"Abstract"},{"location":"docs/contributing/3.-code-of-conduct/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"docs/contributing/3.-code-of-conduct/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"docs/contributing/3.-code-of-conduct/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"docs/contributing/3.-code-of-conduct/#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"docs/contributing/3.-code-of-conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting timothy.crosley@gmail.com . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. Confidentiality will be maintained with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"docs/contributing/3.-code-of-conduct/#attribution","text":"This Code of Conduct is adapted from the [Contributor Covenant][https://www.contributor-covenant.org], version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"Attribution"},{"location":"docs/contributing/4.-acknowledgements/","text":"Contributors Core Developers Timothy Edmund Crosley (@timothycrosley) Notable Bug Reporters - Code Contributors - Documenters Zach Valenta (@zachvalenta) A sincere thanks to everyone who helps make pdocs into a great Python3 project! ~Timothy Crosley","title":"4. Acknowledgements"},{"location":"docs/contributing/4.-acknowledgements/#contributors","text":"","title":"Contributors"},{"location":"docs/contributing/4.-acknowledgements/#core-developers","text":"Timothy Edmund Crosley (@timothycrosley)","title":"Core Developers"},{"location":"docs/contributing/4.-acknowledgements/#notable-bug-reporters","text":"-","title":"Notable Bug Reporters"},{"location":"docs/contributing/4.-acknowledgements/#code-contributors","text":"-","title":"Code Contributors"},{"location":"docs/contributing/4.-acknowledgements/#documenters","text":"Zach Valenta (@zachvalenta) A sincere thanks to everyone who helps make pdocs into a great Python3 project! ~Timothy Crosley","title":"Documenters"},{"location":"docs/quick_start/1.-installation/","text":"Install pdocs into your projects virtual environment: pip3 install pdocs OR poetry add pdocs OR pipenv install pdocs Info It's important that pdocs be installed in your project's environment as it needs to introspect your package to generate reference documentation. You must also have your project installed in the environment for this to work.","title":"1. Installation"},{"location":"docs/quick_start/2.-cli/","text":"Command Line Usage Once installed, pdocs exposes a simple command line utility for generating documentation websites. To verify the tool is installed correctly, run pdocs from the command line and you should be given the available commands and the version of pdocs installed. To get help for any individual subcommand run pdocs SUBCOMMAND --help : Serving Documentation Locally Before you push documentation out publicly, it's a good idea to test it locally and ensure it looks as desired. Running pdocs server YOUR_MODULES will generate a new static website for your project in a temporary directory and start a local server to allow you to browse it (at localhost:8080 by default). This command takes an optional --port and --host argument if you wish to override the defaults. Tip Every module you pass in to pdocs must be installed or otherwise available on your PYTHON_PATH Outputting HTML Locally You can also output pdocs 's generated documentation to a local directory. To do so run pdocs as_html YOUR_MODULES : By default the generated documentation is outputted into a site subdirectory. If this directory exists for any reason, including previous documentation generation, the command will fail. Passing in --overwrite will delete any existing directory before output to ensure the command passes. You can change the output directory using -o DIRECTORY . Outputting Markdown Locally It is also straight-forward to output Markdown documentation for your project generated from your code via pdocs . To do so run pdocs as_markdown YOUR_MODULES : By default the generated documentation is outputted into a docs subdirectory. If this directory exists for any reason, including previous documentation generation, the command will fail. Passing in --overwrite will delete any existing directory before output to ensure the command passes. You can change the output directory using -o DIRECTORY .","title":"2. Cli"},{"location":"docs/quick_start/2.-cli/#command-line-usage","text":"Once installed, pdocs exposes a simple command line utility for generating documentation websites. To verify the tool is installed correctly, run pdocs from the command line and you should be given the available commands and the version of pdocs installed. To get help for any individual subcommand run pdocs SUBCOMMAND --help :","title":"Command Line Usage"},{"location":"docs/quick_start/2.-cli/#serving-documentation-locally","text":"Before you push documentation out publicly, it's a good idea to test it locally and ensure it looks as desired. Running pdocs server YOUR_MODULES will generate a new static website for your project in a temporary directory and start a local server to allow you to browse it (at localhost:8080 by default). This command takes an optional --port and --host argument if you wish to override the defaults. Tip Every module you pass in to pdocs must be installed or otherwise available on your PYTHON_PATH","title":"Serving Documentation Locally"},{"location":"docs/quick_start/2.-cli/#outputting-html-locally","text":"You can also output pdocs 's generated documentation to a local directory. To do so run pdocs as_html YOUR_MODULES : By default the generated documentation is outputted into a site subdirectory. If this directory exists for any reason, including previous documentation generation, the command will fail. Passing in --overwrite will delete any existing directory before output to ensure the command passes. You can change the output directory using -o DIRECTORY .","title":"Outputting HTML Locally"},{"location":"docs/quick_start/2.-cli/#outputting-markdown-locally","text":"It is also straight-forward to output Markdown documentation for your project generated from your code via pdocs . To do so run pdocs as_markdown YOUR_MODULES : By default the generated documentation is outputted into a docs subdirectory. If this directory exists for any reason, including previous documentation generation, the command will fail. Passing in --overwrite will delete any existing directory before output to ensure the command passes. You can change the output directory using -o DIRECTORY .","title":"Outputting Markdown Locally"},{"location":"docs/quick_start/3.-api/","text":"Programmatic Python API Usage Every command available from the command line utility is also available directly as function calls within Python. To use the Python API, import pdocs and then call the desired function call: Every function is type hinted and takes and returns only builtin Python objects. For a full definition of the API see the API reference documentation .","title":"3. Api"},{"location":"docs/quick_start/3.-api/#programmatic-python-api-usage","text":"Every command available from the command line utility is also available directly as function calls within Python. To use the Python API, import pdocs and then call the desired function call: Every function is type hinted and takes and returns only builtin Python objects. For a full definition of the API see the API reference documentation .","title":"Programmatic Python API Usage"},{"location":"pdocs/templates/","text":"The license included in this directory is for HTML5 Boiler Plate . Some of the HTML and CSS used here is derived from that project.","title":"Home"},{"location":"reference/pdocs/","text":"Module pdocs Module pdoc provides types and functions for accessing the public documentation of a Python module. This includes modules (and sub-modules), functions, classes and module, class and instance variables. Docstrings are taken from modules, functions and classes using the special __doc__ attribute. Docstrings for variables are extracted by examining the module's abstract syntax tree. The public interface of a module is determined through one of two ways. If __all__ is defined in the module, then all identifiers in that list will be considered public. No other identifiers will be considered as public. Conversely, if __all__ is not defined, then pdoc will heuristically determine the public interface. There are three rules that are applied to each identifier in the module: If the name starts with an underscore, it is not public. If the name is defined in a different module, it is not public. If the name refers to an immediate sub-module, then it is public. Once documentation for a module is created with pdoc.Module , it can be output as either HTML or plain text using the covenience functions pdoc.html and pdoc.text , or the corresponding methods pdoc.Module.html and pdoc.Module.text . Alternatively, you may run an HTTP server with the pdoc script included with this module. Compatibility pdoc requires Python 3.6 or later. Contributing pdoc is on GitHub . Pull requests and bug reports are welcome. Linking to other identifiers In your documentation, you may link to other identifiers in your module or submodules. Linking is automatically done for you whenever you surround an identifier with a back quote (grave). The identifier name must be fully qualified. For example, pdoc.Doc.docstring is correct while Doc.docstring is incorrect. If the pdoc script is used to run an HTTP server, then external linking to other packages installed is possible. No extra work is necessary; simply use the fully qualified path. For example, nflvid.slice will create a link to the nflvid.slice function, which is not a part of pdoc at all. Where does pdoc get documentation from? Broadly speaking, pdoc gets everything you see from introspecting the module. This includes words describing a particular module, class, function or variable. While pdoc does some analysis on the source code of a module, importing the module itself is necessary to use Python's introspection features. In Python, objects like modules, functions, classes and methods have a special attribute named __doc__ which contains that object's docstring . The docstring comes from a special placement of a string in your source code. For example, the following code shows how to define a function with a docstring and access the contents of that docstring: 1 2 3 4 5 6 >>> def test (): ... '''This is a docstring.''' ... pass ... >>> test . __doc__ 'This is a docstring.' Something similar can be done for classes and modules too. For classes, the docstring should come on the line immediately following class ... . For modules, the docstring should start on the first line of the file. These docstrings are what you see for each module, class, function and method listed in the documentation produced by pdoc . The above just about covers standard uses of docstrings in Python. pdoc extends the above in a few important ways. Special docstring conventions used by pdoc Firstly , docstrings can be inherited. Consider the following code sample: 1 2 3 4 5 6 7 8 9 10 11 12 >>> class A ( object ): ... def test (): ... '''Docstring for A.''' ... >>> class B ( A ): ... def test (): ... pass ... >>> print ( A . test . __doc__ ) Docstring for A . >>> print ( B . test . __doc__ ) None In Python, the docstring for B.test is empty, even though one was defined in A.test . If pdoc generates documentation for the above code, then it will automatically attach the docstring for A.test to B.test only if B.test does not have a docstring. In the default HTML output, an inherited docstring is grey. Secondly , docstrings can be attached to variables, which includes module (or global) variables, class variables and instance variables. Python by itself does not allow docstrings to be attached to variables . For example: 1 2 variable = \"SomeValue\" '''Docstring for variable.''' The resulting variable will have no __doc__ attribute. To compensate, pdoc will read the source code when it's available to infer a connection between a variable and a docstring. The connection is only made when an assignment statement is followed by a docstring. Something similar is done for instance variables as well. By convention, instance variables are initialized in a class's __init__ method. Therefore, pdoc adheres to that convention and looks for docstrings of variables like so: 1 2 3 def __init__ ( self ): self . variable = \"SomeValue\" '''Docstring for instance variable.''' Note that pdoc only considers attributes defined on self as instance variables. Class and instance variables can also have inherited docstrings. Thirdly and finally , docstrings can be overridden with a special __pdoc__ dictionary that pdoc inspects if it exists. The keys of __pdoc__ should be identifiers within the scope of the module. (In the case of an instance variable self.variable for class A , its module identifier would be A.variable .) The values of __pdoc__ should be docstrings. This particular feature is useful when there's no feasible way of attaching a docstring to something. A good example of this is a namedtuple : 1 2 3 4 5 6 __pdoc__ = {} Table = namedtuple ( 'Table' , [ 'types' , 'names' , 'rows' ]) __pdoc__ [ 'Table.types' ] = 'Types for each column in the table.' __pdoc__ [ 'Table.names' ] = 'The names of each column in the table.' __pdoc__ [ 'Table.rows' ] = 'Lists corresponding to each row in the table.' pdoc will then show Table as a class with documentation for the types , names and rows members. Note that assignments to __pdoc__ need to placed where they'll be executed when the module is imported. For example, at the top level of a module or in the definition of a class. If __pdoc__[key] = None , then key will not be included in the public interface of the module. View Source \"\"\" Module pdoc provides types and functions for accessing the public documentation of a Python module . This includes modules ( and sub - modules ) , functions , classes and module , class and instance variables . Docstrings are taken from modules , functions and classes using the special ` __doc__ ` attribute . Docstrings for variables are extracted by examining the module ' s abstract syntax tree. The public interface of a module is determined through one of two ways . If ` __all__ ` is defined in the module , then all identifiers in that list will be considered public . No other identifiers will be considered as public . Conversely , if ` __all__ ` is not defined , then ` pdoc ` will heuristically determine the public interface . There are three rules that are applied to each identifier in the module : 1 . If the name starts with an underscore , it is ** not ** public . 2 . If the name is defined in a different module , it is ** not ** public . 3 . If the name refers to an immediate sub - module , then it is public . Once documentation for a module is created with ` pdoc . Module `, it can be output as either HTML or plain text using the covenience functions ` pdoc . html ` and ` pdoc . text `, or the corresponding methods ` pdoc . Module . html ` and ` pdoc . Module . text `. Alternatively , you may run an HTTP server with the ` pdoc ` script included with this module . Compatibility ------------- ` pdoc ` requires Python 3 . 6 or later . Contributing ------------ ` pdoc ` [ is on GitHub ] ( https : // github . com / mitmproxy / pdoc ) . Pull requests and bug reports are welcome . Linking to other identifiers ---------------------------- In your documentation , you may link to other identifiers in your module or submodules . Linking is automatically done for you whenever you surround an identifier with a back quote ( grave ) . The identifier name must be fully qualified . For example , < code > ` pdoc . Doc . docstring ` </ code > is correct while < code > ` Doc . docstring ` </ code > is incorrect . If the ` pdoc ` script is used to run an HTTP server , then external linking to other packages installed is possible . No extra work is necessary ; simply use the fully qualified path. For example, < code > ` nflvid . slice ` </ code > will create a link to the ` nflvid . slice ` function , which is ** not ** a part of ` pdoc ` at all . Where does pdoc get documentation from ? --------------------------------------- Broadly speaking , ` pdoc ` gets everything you see from introspecting the module . This includes words describing a particular module , class , function or variable . While ` pdoc ` does some analysis on the source code of a module , importing the module itself is necessary to use Python ' s introspection features. In Python , objects like modules , functions , classes and methods have a special attribute named ` __doc__ ` which contains that object ' s * docstring * . The docstring comes from a special placement of a string in your source code . For example , the following code shows how to define a function with a docstring and access the contents of that docstring : # ! python >>> def test () : ... ''' This is a docstring. ''' ... pass ... >>> test . __doc__ ' This is a docstring. ' Something similar can be done for classes and modules too . For classes , the docstring should come on the line immediately following ` class ...`. For modules , the docstring should start on the first line of the file . These docstrings are what you see for each module , class , function and method listed in the documentation produced by ` pdoc `. The above just about covers * standard * uses of docstrings in Python . ` pdoc ` extends the above in a few important ways . ### Special docstring conventions used by ` pdoc ` ** Firstly ** , docstrings can be inherited . Consider the following code sample : # ! python >>> class A ( object ) : ... def test () : ... ''' Docstring for A. ''' ... >>> class B ( A ) : ... def test () : ... pass ... >>> print ( A . test . __doc__ ) Docstring for A . >>> print ( B . test . __doc__ ) None In Python , the docstring for ` B . test ` is empty , even though one was defined in ` A . test `. If ` pdoc ` generates documentation for the above code , then it will automatically attach the docstring for ` A . test ` to ` B . test ` only if ` B . test ` does not have a docstring . In the default HTML output , an inherited docstring is grey . ** Secondly ** , docstrings can be attached to variables , which includes module ( or global ) variables , class variables and instance variables . Python by itself [ does not allow docstrings to be attached to variables ] ( http : // www . python . org / dev / peps / pep - 0224 ) . For example : # ! python variable = \" SomeValue \" ''' Docstring for variable. ''' The resulting ` variable ` will have no ` __doc__ ` attribute . To compensate , ` pdoc ` will read the source code when it ' s available to infer a connection between a variable and a docstring . The connection is only made when an assignment statement is followed by a docstring . Something similar is done for instance variables as well . By convention , instance variables are initialized in a class ' s `__init__` method . Therefore , ` pdoc ` adheres to that convention and looks for docstrings of variables like so : # ! python def __init__ ( self ) : self . variable = \" SomeValue \" ''' Docstring for instance variable. ''' Note that ` pdoc ` only considers attributes defined on ` self ` as instance variables . Class and instance variables can also have inherited docstrings . ** Thirdly and finally ** , docstrings can be overridden with a special ` __pdoc__ ` dictionary that ` pdoc ` inspects if it exists . The keys of ` __pdoc__ ` should be identifiers within the scope of the module . ( In the case of an instance variable ` self . variable ` for class ` A `, its module identifier would be ` A . variable `. ) The values of ` __pdoc__ ` should be docstrings . This particular feature is useful when there ' s no feasible way of attaching a docstring to something . A good example of this is a [ namedtuple ] ( http : // goo . gl / akfXJ9 ) : # ! python __pdoc__ = {} Table = namedtuple ( ' Table ' , [ ' types ' , ' names ' , ' rows ' ] ) __pdoc__ [ ' Table.types ' ] = ' Types for each column in the table. ' __pdoc__ [ ' Table.names ' ] = ' The names of each column in the table. ' __pdoc__ [ ' Table.rows ' ] = ' Lists corresponding to each row in the table. ' ` pdoc ` will then show ` Table ` as a class with documentation for the ` types `, ` names ` and ` rows ` members . Note that assignments to ` __pdoc__ ` need to placed where they ' ll be executed when the module is imported . For example , at the top level of a module or in the definition of a class . If ` __pdoc__ [ key ] = None `, then ` key ` will not be included in the public interface of the module . \"\"\" from pdocs . _version import __version__ from pdocs . api import as_html , as_markdown , server Sub-modules pdocs.api pdocs.cli pdocs.defaults pdocs.doc pdocs.extract pdocs.html_helpers pdocs.logo pdocs.render pdocs.static","title":"Index"},{"location":"reference/pdocs/#module-pdocs","text":"Module pdoc provides types and functions for accessing the public documentation of a Python module. This includes modules (and sub-modules), functions, classes and module, class and instance variables. Docstrings are taken from modules, functions and classes using the special __doc__ attribute. Docstrings for variables are extracted by examining the module's abstract syntax tree. The public interface of a module is determined through one of two ways. If __all__ is defined in the module, then all identifiers in that list will be considered public. No other identifiers will be considered as public. Conversely, if __all__ is not defined, then pdoc will heuristically determine the public interface. There are three rules that are applied to each identifier in the module: If the name starts with an underscore, it is not public. If the name is defined in a different module, it is not public. If the name refers to an immediate sub-module, then it is public. Once documentation for a module is created with pdoc.Module , it can be output as either HTML or plain text using the covenience functions pdoc.html and pdoc.text , or the corresponding methods pdoc.Module.html and pdoc.Module.text . Alternatively, you may run an HTTP server with the pdoc script included with this module.","title":"Module pdocs"},{"location":"reference/pdocs/#compatibility","text":"pdoc requires Python 3.6 or later.","title":"Compatibility"},{"location":"reference/pdocs/#contributing","text":"pdoc is on GitHub . Pull requests and bug reports are welcome.","title":"Contributing"},{"location":"reference/pdocs/#linking-to-other-identifiers","text":"In your documentation, you may link to other identifiers in your module or submodules. Linking is automatically done for you whenever you surround an identifier with a back quote (grave). The identifier name must be fully qualified. For example, pdoc.Doc.docstring is correct while Doc.docstring is incorrect. If the pdoc script is used to run an HTTP server, then external linking to other packages installed is possible. No extra work is necessary; simply use the fully qualified path. For example, nflvid.slice will create a link to the nflvid.slice function, which is not a part of pdoc at all.","title":"Linking to other identifiers"},{"location":"reference/pdocs/#where-does-pdoc-get-documentation-from","text":"Broadly speaking, pdoc gets everything you see from introspecting the module. This includes words describing a particular module, class, function or variable. While pdoc does some analysis on the source code of a module, importing the module itself is necessary to use Python's introspection features. In Python, objects like modules, functions, classes and methods have a special attribute named __doc__ which contains that object's docstring . The docstring comes from a special placement of a string in your source code. For example, the following code shows how to define a function with a docstring and access the contents of that docstring: 1 2 3 4 5 6 >>> def test (): ... '''This is a docstring.''' ... pass ... >>> test . __doc__ 'This is a docstring.' Something similar can be done for classes and modules too. For classes, the docstring should come on the line immediately following class ... . For modules, the docstring should start on the first line of the file. These docstrings are what you see for each module, class, function and method listed in the documentation produced by pdoc . The above just about covers standard uses of docstrings in Python. pdoc extends the above in a few important ways.","title":"Where does pdoc get documentation from?"},{"location":"reference/pdocs/#special-docstring-conventions-used-by-pdoc","text":"Firstly , docstrings can be inherited. Consider the following code sample: 1 2 3 4 5 6 7 8 9 10 11 12 >>> class A ( object ): ... def test (): ... '''Docstring for A.''' ... >>> class B ( A ): ... def test (): ... pass ... >>> print ( A . test . __doc__ ) Docstring for A . >>> print ( B . test . __doc__ ) None In Python, the docstring for B.test is empty, even though one was defined in A.test . If pdoc generates documentation for the above code, then it will automatically attach the docstring for A.test to B.test only if B.test does not have a docstring. In the default HTML output, an inherited docstring is grey. Secondly , docstrings can be attached to variables, which includes module (or global) variables, class variables and instance variables. Python by itself does not allow docstrings to be attached to variables . For example: 1 2 variable = \"SomeValue\" '''Docstring for variable.''' The resulting variable will have no __doc__ attribute. To compensate, pdoc will read the source code when it's available to infer a connection between a variable and a docstring. The connection is only made when an assignment statement is followed by a docstring. Something similar is done for instance variables as well. By convention, instance variables are initialized in a class's __init__ method. Therefore, pdoc adheres to that convention and looks for docstrings of variables like so: 1 2 3 def __init__ ( self ): self . variable = \"SomeValue\" '''Docstring for instance variable.''' Note that pdoc only considers attributes defined on self as instance variables. Class and instance variables can also have inherited docstrings. Thirdly and finally , docstrings can be overridden with a special __pdoc__ dictionary that pdoc inspects if it exists. The keys of __pdoc__ should be identifiers within the scope of the module. (In the case of an instance variable self.variable for class A , its module identifier would be A.variable .) The values of __pdoc__ should be docstrings. This particular feature is useful when there's no feasible way of attaching a docstring to something. A good example of this is a namedtuple : 1 2 3 4 5 6 __pdoc__ = {} Table = namedtuple ( 'Table' , [ 'types' , 'names' , 'rows' ]) __pdoc__ [ 'Table.types' ] = 'Types for each column in the table.' __pdoc__ [ 'Table.names' ] = 'The names of each column in the table.' __pdoc__ [ 'Table.rows' ] = 'Lists corresponding to each row in the table.' pdoc will then show Table as a class with documentation for the types , names and rows members. Note that assignments to __pdoc__ need to placed where they'll be executed when the module is imported. For example, at the top level of a module or in the definition of a class. If __pdoc__[key] = None , then key will not be included in the public interface of the module. View Source \"\"\" Module pdoc provides types and functions for accessing the public documentation of a Python module . This includes modules ( and sub - modules ) , functions , classes and module , class and instance variables . Docstrings are taken from modules , functions and classes using the special ` __doc__ ` attribute . Docstrings for variables are extracted by examining the module ' s abstract syntax tree. The public interface of a module is determined through one of two ways . If ` __all__ ` is defined in the module , then all identifiers in that list will be considered public . No other identifiers will be considered as public . Conversely , if ` __all__ ` is not defined , then ` pdoc ` will heuristically determine the public interface . There are three rules that are applied to each identifier in the module : 1 . If the name starts with an underscore , it is ** not ** public . 2 . If the name is defined in a different module , it is ** not ** public . 3 . If the name refers to an immediate sub - module , then it is public . Once documentation for a module is created with ` pdoc . Module `, it can be output as either HTML or plain text using the covenience functions ` pdoc . html ` and ` pdoc . text `, or the corresponding methods ` pdoc . Module . html ` and ` pdoc . Module . text `. Alternatively , you may run an HTTP server with the ` pdoc ` script included with this module . Compatibility ------------- ` pdoc ` requires Python 3 . 6 or later . Contributing ------------ ` pdoc ` [ is on GitHub ] ( https : // github . com / mitmproxy / pdoc ) . Pull requests and bug reports are welcome . Linking to other identifiers ---------------------------- In your documentation , you may link to other identifiers in your module or submodules . Linking is automatically done for you whenever you surround an identifier with a back quote ( grave ) . The identifier name must be fully qualified . For example , < code > ` pdoc . Doc . docstring ` </ code > is correct while < code > ` Doc . docstring ` </ code > is incorrect . If the ` pdoc ` script is used to run an HTTP server , then external linking to other packages installed is possible . No extra work is necessary ; simply use the fully qualified path. For example, < code > ` nflvid . slice ` </ code > will create a link to the ` nflvid . slice ` function , which is ** not ** a part of ` pdoc ` at all . Where does pdoc get documentation from ? --------------------------------------- Broadly speaking , ` pdoc ` gets everything you see from introspecting the module . This includes words describing a particular module , class , function or variable . While ` pdoc ` does some analysis on the source code of a module , importing the module itself is necessary to use Python ' s introspection features. In Python , objects like modules , functions , classes and methods have a special attribute named ` __doc__ ` which contains that object ' s * docstring * . The docstring comes from a special placement of a string in your source code . For example , the following code shows how to define a function with a docstring and access the contents of that docstring : # ! python >>> def test () : ... ''' This is a docstring. ''' ... pass ... >>> test . __doc__ ' This is a docstring. ' Something similar can be done for classes and modules too . For classes , the docstring should come on the line immediately following ` class ...`. For modules , the docstring should start on the first line of the file . These docstrings are what you see for each module , class , function and method listed in the documentation produced by ` pdoc `. The above just about covers * standard * uses of docstrings in Python . ` pdoc ` extends the above in a few important ways . ### Special docstring conventions used by ` pdoc ` ** Firstly ** , docstrings can be inherited . Consider the following code sample : # ! python >>> class A ( object ) : ... def test () : ... ''' Docstring for A. ''' ... >>> class B ( A ) : ... def test () : ... pass ... >>> print ( A . test . __doc__ ) Docstring for A . >>> print ( B . test . __doc__ ) None In Python , the docstring for ` B . test ` is empty , even though one was defined in ` A . test `. If ` pdoc ` generates documentation for the above code , then it will automatically attach the docstring for ` A . test ` to ` B . test ` only if ` B . test ` does not have a docstring . In the default HTML output , an inherited docstring is grey . ** Secondly ** , docstrings can be attached to variables , which includes module ( or global ) variables , class variables and instance variables . Python by itself [ does not allow docstrings to be attached to variables ] ( http : // www . python . org / dev / peps / pep - 0224 ) . For example : # ! python variable = \" SomeValue \" ''' Docstring for variable. ''' The resulting ` variable ` will have no ` __doc__ ` attribute . To compensate , ` pdoc ` will read the source code when it ' s available to infer a connection between a variable and a docstring . The connection is only made when an assignment statement is followed by a docstring . Something similar is done for instance variables as well . By convention , instance variables are initialized in a class ' s `__init__` method . Therefore , ` pdoc ` adheres to that convention and looks for docstrings of variables like so : # ! python def __init__ ( self ) : self . variable = \" SomeValue \" ''' Docstring for instance variable. ''' Note that ` pdoc ` only considers attributes defined on ` self ` as instance variables . Class and instance variables can also have inherited docstrings . ** Thirdly and finally ** , docstrings can be overridden with a special ` __pdoc__ ` dictionary that ` pdoc ` inspects if it exists . The keys of ` __pdoc__ ` should be identifiers within the scope of the module . ( In the case of an instance variable ` self . variable ` for class ` A `, its module identifier would be ` A . variable `. ) The values of ` __pdoc__ ` should be docstrings . This particular feature is useful when there ' s no feasible way of attaching a docstring to something . A good example of this is a [ namedtuple ] ( http : // goo . gl / akfXJ9 ) : # ! python __pdoc__ = {} Table = namedtuple ( ' Table ' , [ ' types ' , ' names ' , ' rows ' ] ) __pdoc__ [ ' Table.types ' ] = ' Types for each column in the table. ' __pdoc__ [ ' Table.names ' ] = ' The names of each column in the table. ' __pdoc__ [ ' Table.rows ' ] = ' Lists corresponding to each row in the table. ' ` pdoc ` will then show ` Table ` as a class with documentation for the ` types `, ` names ` and ` rows ` members . Note that assignments to ` __pdoc__ ` need to placed where they ' ll be executed when the module is imported . For example , at the top level of a module or in the definition of a class . If ` __pdoc__ [ key ] = None `, then ` key ` will not be included in the public interface of the module . \"\"\" from pdocs . _version import __version__ from pdocs . api import as_html , as_markdown , server","title":"Special docstring conventions used by pdoc"},{"location":"reference/pdocs/#sub-modules","text":"pdocs.api pdocs.cli pdocs.defaults pdocs.doc pdocs.extract pdocs.html_helpers pdocs.logo pdocs.render pdocs.static","title":"Sub-modules"},{"location":"reference/pdocs/api/","text":"Module pdocs.api This module defines the programmatic API that can be used to interact with pdocs to generate and view documentation from Python source code. If you want to extend pdocs or use it directly from within Python - this is the place to start. View Source \"\"\"This module defines the programmatic API that can be used to interact with `pdocs` to generate and view documentation from Python source code. If you want to extend `pdocs` or use it directly from within Python - this is the place to start. \"\"\" import os import pathlib import sys import tempfile import webbrowser import hug import pdocs.extract import pdocs.logo import pdocs.render import pdocs.static from pdocs import defaults def as_html ( modules : list , output_dir : str = defaults . HTML_OUTPUT_DIRECTORY , overwrite : bool = False , external_links : bool = False , exclude_source : bool = False , link_prefix : str = \"\" , template_dir : str = \"\" , ) -> str : \"\"\"Produces HTML formatted output into the specified output_dir. - *modules*: One or more python module names. These may be import paths resolvable in the current environment, or file paths to a Python module or package. - *output_dir*: The directory to output HTML files to. - *overwrite*: If set, will overwrites any existing files in the output location. - *external_links*: When set, identifiers to external modules are turned into links. - *exclude_source*: When set, source code will not be viewable in the generated HTML. - *link_prefix*: A prefix to use for every link in the generated documentation otherwise relative links will be used. - *template_dir*: Specify a directory containing override Mako templates. Returns the `output_dir` on success. \"\"\" if template_dir : pdocs . render . tpl_lookup . directories . insert ( 0 , template_dir ) roots = _get_root_modules ( modules ) destination = _destination ( output_dir , roots , overwrite ) pdocs . static . html_out ( destination , roots , external_links = external_links , source = not exclude_source , link_prefix = link_prefix , ) return output_dir def as_markdown ( modules : list , output_dir : str = defaults . MARKDOWN_OUTPUT_DIRECTORY , overwrite : bool = False , exclude_source : bool = False , template_dir : str = \"\" , ) -> str : \"\"\"Produces Markdown formatted output into the specified output_dir. - *modules*: One or more python module names. These may be import paths resolvable in the current environment, or file paths to a Python module or package. - *output_dir*: The directory to output HTML files to. - *overwrite*: If set, will overwrites any existing files in the output location. - *exclude_source*: When set, source code will not be viewable in the generated Markdown. - *template_dir*: Specify a directory containing override Mako templates. Returns the `output_dir` on success. \"\"\" if template_dir : pdocs . render . tpl_lookup . directories . insert ( 0 , template_dir ) roots = _get_root_modules ( modules ) destination = _destination ( output_dir , roots , overwrite ) pdocs . static . md_out ( destination , roots , source = not exclude_source ) return output_dir def server ( modules : list , external_links : bool = False , exclude_source : bool = False , link_prefix : str = \"\" , template_dir : str = \"\" , open_browser : bool = False , port : int = defaults . SERVER_PORT , host : str = defaults . SERVER_HOST , ) -> None : \"\"\"Runs a development webserver enabling you to browse documentation locally. - *modules*: One or more python module names. These may be import paths resolvable in the current environment, or file paths to a Python module or package. - *external_links*: When set, identifiers to external modules are turned into links. - *exclude_source*: When set, source code will not be viewable in the generated HTML. - *link_prefix*: A prefix to use for every link in the generated documentation otherwise relative links will be used. - *template_dir*: Specify a directory containing override Mako templates. - *open_browser*: If true a browser will be opened pointing at the documentation server - *port*: The port to expose your documentation on (defaults to: `8000`) - *host*: The host to expose your documentation on (defaults to `\"127.0.0.1\"`) \"\"\" with tempfile . TemporaryDirectory () as output_dir : as_html ( modules , overwrite = True , output_dir = output_dir , external_links = external_links , template_dir = template_dir , ) if len ( modules ) == 1 : output_dir = os . path . join ( output_dir , modules [ 0 ]) api = hug . API ( \"Doc Server\" ) @hug.static ( \"/\" , api = api ) def my_static_dirs (): # pragma: no cover return ( output_dir ,) @hug.startup ( api = api ) def custom_startup ( * args , ** kwargs ): # pragma: no cover print ( pdocs . logo . ascii_art ) if open_browser : webbrowser . open_new ( f \"http://{host}:{port}\" ) api . http . serve ( host = host , port = port , no_documentation = True , display_intro = False ) def _get_root_modules ( module_names ): if not module_names : sys . exit ( \"Please provide one or more modules\" ) try : return [ pdocs . extract . extract_module ( module_name ) for module_name in module_names ] except pdocs . extract . ExtractError as error : sys . exit ( str ( error )) def _destination ( directory , root_modules , overwrite ): destination = pathlib . Path ( directory ) if not overwrite and pdocs . static . would_overwrite ( destination , root_modules ): sys . exit ( \"Rendering would overwrite files, but --overwrite is not set\" ) return destination Functions as_html def ( modules : list , output_dir : str = 'site' , overwrite : bool = False , external_links : bool = False , exclude_source : bool = False , link_prefix : str = '' , template_dir : str = '' ) -> str Produces HTML formatted output into the specified output_dir. modules : One or more python module names. These may be import paths resolvable in the current environment, or file paths to a Python module or package. output_dir : The directory to output HTML files to. overwrite : If set, will overwrites any existing files in the output location. external_links : When set, identifiers to external modules are turned into links. exclude_source : When set, source code will not be viewable in the generated HTML. link_prefix : A prefix to use for every link in the generated documentation otherwise relative links will be used. template_dir : Specify a directory containing override Mako templates. Returns the output_dir on success. View Source def as_html ( modules : list , output_dir : str = defaults . HTML_OUTPUT_DIRECTORY , overwrite : bool = False , external_links : bool = False , exclude_source : bool = False , link_prefix : str = \"\" , template_dir : str = \"\" , ) -> str : \"\"\"Produces HTML formatted output into the specified output_dir. - *modules*: One or more python module names. These may be import paths resolvable in the current environment, or file paths to a Python module or package. - *output_dir*: The directory to output HTML files to. - *overwrite*: If set, will overwrites any existing files in the output location. - *external_links*: When set, identifiers to external modules are turned into links. - *exclude_source*: When set, source code will not be viewable in the generated HTML. - *link_prefix*: A prefix to use for every link in the generated documentation otherwise relative links will be used. - *template_dir*: Specify a directory containing override Mako templates. Returns the `output_dir` on success. \"\"\" if template_dir : pdocs . render . tpl_lookup . directories . insert ( 0 , template_dir ) roots = _get_root_modules ( modules ) destination = _destination ( output_dir , roots , overwrite ) pdocs . static . html_out ( destination , roots , external_links = external_links , source = not exclude_source , link_prefix = link_prefix , ) return output_dir as_markdown def ( modules : list , output_dir : str = 'docs' , overwrite : bool = False , exclude_source : bool = False , template_dir : str = '' ) -> str Produces Markdown formatted output into the specified output_dir. modules : One or more python module names. These may be import paths resolvable in the current environment, or file paths to a Python module or package. output_dir : The directory to output HTML files to. overwrite : If set, will overwrites any existing files in the output location. exclude_source : When set, source code will not be viewable in the generated Markdown. template_dir : Specify a directory containing override Mako templates. Returns the output_dir on success. View Source def as_markdown ( modules : list , output_dir : str = defaults . MARKDOWN_OUTPUT_DIRECTORY , overwrite : bool = False , exclude_source : bool = False , template_dir : str = \"\" , ) -> str : \"\"\"Produces Markdown formatted output into the specified output_dir. - *modules*: One or more python module names. These may be import paths resolvable in the current environment, or file paths to a Python module or package. - *output_dir*: The directory to output HTML files to. - *overwrite*: If set, will overwrites any existing files in the output location. - *exclude_source*: When set, source code will not be viewable in the generated Markdown. - *template_dir*: Specify a directory containing override Mako templates. Returns the `output_dir` on success. \"\"\" if template_dir : pdocs . render . tpl_lookup . directories . insert ( 0 , template_dir ) roots = _get_root_modules ( modules ) destination = _destination ( output_dir , roots , overwrite ) pdocs . static . md_out ( destination , roots , source = not exclude_source ) return output_dir server def ( modules : list , external_links : bool = False , exclude_source : bool = False , link_prefix : str = '' , template_dir : str = '' , open_browser : bool = False , port : int = 8080 , host : str = '127.0.0.1' ) -> None Runs a development webserver enabling you to browse documentation locally. modules : One or more python module names. These may be import paths resolvable in the current environment, or file paths to a Python module or package. external_links : When set, identifiers to external modules are turned into links. exclude_source : When set, source code will not be viewable in the generated HTML. link_prefix : A prefix to use for every link in the generated documentation otherwise relative links will be used. template_dir : Specify a directory containing override Mako templates. open_browser : If true a browser will be opened pointing at the documentation server port : The port to expose your documentation on (defaults to: 8000 ) host : The host to expose your documentation on (defaults to \"127.0.0.1\" ) View Source def server ( modules : list , external_links : bool = False , exclude_source : bool = False , link_prefix : str = \"\" , template_dir : str = \"\" , open_browser : bool = False , port : int = defaults . SERVER_PORT , host : str = defaults . SERVER_HOST , ) -> None : \"\"\"Runs a development webserver enabling you to browse documentation locally. - *modules*: One or more python module names. These may be import paths resolvable in the current environment, or file paths to a Python module or package. - *external_links*: When set, identifiers to external modules are turned into links. - *exclude_source*: When set, source code will not be viewable in the generated HTML. - *link_prefix*: A prefix to use for every link in the generated documentation otherwise relative links will be used. - *template_dir*: Specify a directory containing override Mako templates. - *open_browser*: If true a browser will be opened pointing at the documentation server - *port*: The port to expose your documentation on (defaults to: `8000`) - *host*: The host to expose your documentation on (defaults to `\"127.0.0.1\"`) \"\"\" with tempfile . TemporaryDirectory () as output_dir : as_html ( modules , overwrite = True , output_dir = output_dir , external_links = external_links , template_dir = template_dir , ) if len ( modules ) == 1 : output_dir = os . path . join ( output_dir , modules [ 0 ]) api = hug . API ( \"Doc Server\" ) @hug.static ( \"/\" , api = api ) def my_static_dirs (): # pragma: no cover return ( output_dir ,) @hug.startup ( api = api ) def custom_startup ( * args , ** kwargs ): # pragma: no cover print ( pdocs . logo . ascii_art ) if open_browser : webbrowser . open_new ( f \"http://{host}:{port}\" ) api . http . serve ( host = host , port = port , no_documentation = True , display_intro = False )","title":"API"},{"location":"reference/pdocs/api/#module-pdocsapi","text":"This module defines the programmatic API that can be used to interact with pdocs to generate and view documentation from Python source code. If you want to extend pdocs or use it directly from within Python - this is the place to start. View Source \"\"\"This module defines the programmatic API that can be used to interact with `pdocs` to generate and view documentation from Python source code. If you want to extend `pdocs` or use it directly from within Python - this is the place to start. \"\"\" import os import pathlib import sys import tempfile import webbrowser import hug import pdocs.extract import pdocs.logo import pdocs.render import pdocs.static from pdocs import defaults def as_html ( modules : list , output_dir : str = defaults . HTML_OUTPUT_DIRECTORY , overwrite : bool = False , external_links : bool = False , exclude_source : bool = False , link_prefix : str = \"\" , template_dir : str = \"\" , ) -> str : \"\"\"Produces HTML formatted output into the specified output_dir. - *modules*: One or more python module names. These may be import paths resolvable in the current environment, or file paths to a Python module or package. - *output_dir*: The directory to output HTML files to. - *overwrite*: If set, will overwrites any existing files in the output location. - *external_links*: When set, identifiers to external modules are turned into links. - *exclude_source*: When set, source code will not be viewable in the generated HTML. - *link_prefix*: A prefix to use for every link in the generated documentation otherwise relative links will be used. - *template_dir*: Specify a directory containing override Mako templates. Returns the `output_dir` on success. \"\"\" if template_dir : pdocs . render . tpl_lookup . directories . insert ( 0 , template_dir ) roots = _get_root_modules ( modules ) destination = _destination ( output_dir , roots , overwrite ) pdocs . static . html_out ( destination , roots , external_links = external_links , source = not exclude_source , link_prefix = link_prefix , ) return output_dir def as_markdown ( modules : list , output_dir : str = defaults . MARKDOWN_OUTPUT_DIRECTORY , overwrite : bool = False , exclude_source : bool = False , template_dir : str = \"\" , ) -> str : \"\"\"Produces Markdown formatted output into the specified output_dir. - *modules*: One or more python module names. These may be import paths resolvable in the current environment, or file paths to a Python module or package. - *output_dir*: The directory to output HTML files to. - *overwrite*: If set, will overwrites any existing files in the output location. - *exclude_source*: When set, source code will not be viewable in the generated Markdown. - *template_dir*: Specify a directory containing override Mako templates. Returns the `output_dir` on success. \"\"\" if template_dir : pdocs . render . tpl_lookup . directories . insert ( 0 , template_dir ) roots = _get_root_modules ( modules ) destination = _destination ( output_dir , roots , overwrite ) pdocs . static . md_out ( destination , roots , source = not exclude_source ) return output_dir def server ( modules : list , external_links : bool = False , exclude_source : bool = False , link_prefix : str = \"\" , template_dir : str = \"\" , open_browser : bool = False , port : int = defaults . SERVER_PORT , host : str = defaults . SERVER_HOST , ) -> None : \"\"\"Runs a development webserver enabling you to browse documentation locally. - *modules*: One or more python module names. These may be import paths resolvable in the current environment, or file paths to a Python module or package. - *external_links*: When set, identifiers to external modules are turned into links. - *exclude_source*: When set, source code will not be viewable in the generated HTML. - *link_prefix*: A prefix to use for every link in the generated documentation otherwise relative links will be used. - *template_dir*: Specify a directory containing override Mako templates. - *open_browser*: If true a browser will be opened pointing at the documentation server - *port*: The port to expose your documentation on (defaults to: `8000`) - *host*: The host to expose your documentation on (defaults to `\"127.0.0.1\"`) \"\"\" with tempfile . TemporaryDirectory () as output_dir : as_html ( modules , overwrite = True , output_dir = output_dir , external_links = external_links , template_dir = template_dir , ) if len ( modules ) == 1 : output_dir = os . path . join ( output_dir , modules [ 0 ]) api = hug . API ( \"Doc Server\" ) @hug.static ( \"/\" , api = api ) def my_static_dirs (): # pragma: no cover return ( output_dir ,) @hug.startup ( api = api ) def custom_startup ( * args , ** kwargs ): # pragma: no cover print ( pdocs . logo . ascii_art ) if open_browser : webbrowser . open_new ( f \"http://{host}:{port}\" ) api . http . serve ( host = host , port = port , no_documentation = True , display_intro = False ) def _get_root_modules ( module_names ): if not module_names : sys . exit ( \"Please provide one or more modules\" ) try : return [ pdocs . extract . extract_module ( module_name ) for module_name in module_names ] except pdocs . extract . ExtractError as error : sys . exit ( str ( error )) def _destination ( directory , root_modules , overwrite ): destination = pathlib . Path ( directory ) if not overwrite and pdocs . static . would_overwrite ( destination , root_modules ): sys . exit ( \"Rendering would overwrite files, but --overwrite is not set\" ) return destination","title":"Module pdocs.api"},{"location":"reference/pdocs/api/#functions","text":"","title":"Functions"},{"location":"reference/pdocs/api/#as_html","text":"def ( modules : list , output_dir : str = 'site' , overwrite : bool = False , external_links : bool = False , exclude_source : bool = False , link_prefix : str = '' , template_dir : str = '' ) -> str Produces HTML formatted output into the specified output_dir. modules : One or more python module names. These may be import paths resolvable in the current environment, or file paths to a Python module or package. output_dir : The directory to output HTML files to. overwrite : If set, will overwrites any existing files in the output location. external_links : When set, identifiers to external modules are turned into links. exclude_source : When set, source code will not be viewable in the generated HTML. link_prefix : A prefix to use for every link in the generated documentation otherwise relative links will be used. template_dir : Specify a directory containing override Mako templates. Returns the output_dir on success. View Source def as_html ( modules : list , output_dir : str = defaults . HTML_OUTPUT_DIRECTORY , overwrite : bool = False , external_links : bool = False , exclude_source : bool = False , link_prefix : str = \"\" , template_dir : str = \"\" , ) -> str : \"\"\"Produces HTML formatted output into the specified output_dir. - *modules*: One or more python module names. These may be import paths resolvable in the current environment, or file paths to a Python module or package. - *output_dir*: The directory to output HTML files to. - *overwrite*: If set, will overwrites any existing files in the output location. - *external_links*: When set, identifiers to external modules are turned into links. - *exclude_source*: When set, source code will not be viewable in the generated HTML. - *link_prefix*: A prefix to use for every link in the generated documentation otherwise relative links will be used. - *template_dir*: Specify a directory containing override Mako templates. Returns the `output_dir` on success. \"\"\" if template_dir : pdocs . render . tpl_lookup . directories . insert ( 0 , template_dir ) roots = _get_root_modules ( modules ) destination = _destination ( output_dir , roots , overwrite ) pdocs . static . html_out ( destination , roots , external_links = external_links , source = not exclude_source , link_prefix = link_prefix , ) return output_dir","title":"as_html"},{"location":"reference/pdocs/api/#as_markdown","text":"def ( modules : list , output_dir : str = 'docs' , overwrite : bool = False , exclude_source : bool = False , template_dir : str = '' ) -> str Produces Markdown formatted output into the specified output_dir. modules : One or more python module names. These may be import paths resolvable in the current environment, or file paths to a Python module or package. output_dir : The directory to output HTML files to. overwrite : If set, will overwrites any existing files in the output location. exclude_source : When set, source code will not be viewable in the generated Markdown. template_dir : Specify a directory containing override Mako templates. Returns the output_dir on success. View Source def as_markdown ( modules : list , output_dir : str = defaults . MARKDOWN_OUTPUT_DIRECTORY , overwrite : bool = False , exclude_source : bool = False , template_dir : str = \"\" , ) -> str : \"\"\"Produces Markdown formatted output into the specified output_dir. - *modules*: One or more python module names. These may be import paths resolvable in the current environment, or file paths to a Python module or package. - *output_dir*: The directory to output HTML files to. - *overwrite*: If set, will overwrites any existing files in the output location. - *exclude_source*: When set, source code will not be viewable in the generated Markdown. - *template_dir*: Specify a directory containing override Mako templates. Returns the `output_dir` on success. \"\"\" if template_dir : pdocs . render . tpl_lookup . directories . insert ( 0 , template_dir ) roots = _get_root_modules ( modules ) destination = _destination ( output_dir , roots , overwrite ) pdocs . static . md_out ( destination , roots , source = not exclude_source ) return output_dir","title":"as_markdown"},{"location":"reference/pdocs/api/#server","text":"def ( modules : list , external_links : bool = False , exclude_source : bool = False , link_prefix : str = '' , template_dir : str = '' , open_browser : bool = False , port : int = 8080 , host : str = '127.0.0.1' ) -> None Runs a development webserver enabling you to browse documentation locally. modules : One or more python module names. These may be import paths resolvable in the current environment, or file paths to a Python module or package. external_links : When set, identifiers to external modules are turned into links. exclude_source : When set, source code will not be viewable in the generated HTML. link_prefix : A prefix to use for every link in the generated documentation otherwise relative links will be used. template_dir : Specify a directory containing override Mako templates. open_browser : If true a browser will be opened pointing at the documentation server port : The port to expose your documentation on (defaults to: 8000 ) host : The host to expose your documentation on (defaults to \"127.0.0.1\" ) View Source def server ( modules : list , external_links : bool = False , exclude_source : bool = False , link_prefix : str = \"\" , template_dir : str = \"\" , open_browser : bool = False , port : int = defaults . SERVER_PORT , host : str = defaults . SERVER_HOST , ) -> None : \"\"\"Runs a development webserver enabling you to browse documentation locally. - *modules*: One or more python module names. These may be import paths resolvable in the current environment, or file paths to a Python module or package. - *external_links*: When set, identifiers to external modules are turned into links. - *exclude_source*: When set, source code will not be viewable in the generated HTML. - *link_prefix*: A prefix to use for every link in the generated documentation otherwise relative links will be used. - *template_dir*: Specify a directory containing override Mako templates. - *open_browser*: If true a browser will be opened pointing at the documentation server - *port*: The port to expose your documentation on (defaults to: `8000`) - *host*: The host to expose your documentation on (defaults to `\"127.0.0.1\"`) \"\"\" with tempfile . TemporaryDirectory () as output_dir : as_html ( modules , overwrite = True , output_dir = output_dir , external_links = external_links , template_dir = template_dir , ) if len ( modules ) == 1 : output_dir = os . path . join ( output_dir , modules [ 0 ]) api = hug . API ( \"Doc Server\" ) @hug.static ( \"/\" , api = api ) def my_static_dirs (): # pragma: no cover return ( output_dir ,) @hug.startup ( api = api ) def custom_startup ( * args , ** kwargs ): # pragma: no cover print ( pdocs . logo . ascii_art ) if open_browser : webbrowser . open_new ( f \"http://{host}:{port}\" ) api . http . serve ( host = host , port = port , no_documentation = True , display_intro = False )","title":"server"},{"location":"reference/pdocs/cli/","text":"Module pdocs.cli View Source import hug from pdocs import api , logo cli = hug . cli ( api = hug . API ( __name__ , doc = logo . ascii_art )) cli ( api . as_html ) cli ( api . as_markdown ) cli ( api . server ) Variables cli","title":"CLI"},{"location":"reference/pdocs/cli/#module-pdocscli","text":"View Source import hug from pdocs import api , logo cli = hug . cli ( api = hug . API ( __name__ , doc = logo . ascii_art )) cli ( api . as_html ) cli ( api . as_markdown ) cli ( api . server )","title":"Module pdocs.cli"},{"location":"reference/pdocs/cli/#variables","text":"cli","title":"Variables"},{"location":"reference/pdocs/defaults/","text":"Module pdocs.defaults View Source SERVER_PORT = 8080 SERVER_HOST = \"127.0.0.1\" HTML_OUTPUT_DIRECTORY = \"site\" MARKDOWN_OUTPUT_DIRECTORY = \"docs\" MARKDOWN_EXTENSIONS = [ \"markdown.extensions.abbr\" , \"markdown.extensions.admonition\" , \"markdown.extensions.attr_list\" , \"markdown.extensions.def_list\" , \"markdown.extensions.fenced_code\" , \"markdown.extensions.footnotes\" , \"markdown.extensions.tables\" , \"markdown.extensions.smarty\" , \"markdown.extensions.toc\" , ] MARKDOWN_EXTENSION_CONFIGS = { \"markdown.extensions.smarty\" : { \"smart_angled_quotes\" : False , \"smart_dashes\" : True , \"smart_quotes\" : False , \"smart_ellipses\" : True , } } Variables HTML_OUTPUT_DIRECTORY MARKDOWN_EXTENSIONS MARKDOWN_EXTENSION_CONFIGS MARKDOWN_OUTPUT_DIRECTORY SERVER_HOST SERVER_PORT","title":"Defaults"},{"location":"reference/pdocs/defaults/#module-pdocsdefaults","text":"View Source SERVER_PORT = 8080 SERVER_HOST = \"127.0.0.1\" HTML_OUTPUT_DIRECTORY = \"site\" MARKDOWN_OUTPUT_DIRECTORY = \"docs\" MARKDOWN_EXTENSIONS = [ \"markdown.extensions.abbr\" , \"markdown.extensions.admonition\" , \"markdown.extensions.attr_list\" , \"markdown.extensions.def_list\" , \"markdown.extensions.fenced_code\" , \"markdown.extensions.footnotes\" , \"markdown.extensions.tables\" , \"markdown.extensions.smarty\" , \"markdown.extensions.toc\" , ] MARKDOWN_EXTENSION_CONFIGS = { \"markdown.extensions.smarty\" : { \"smart_angled_quotes\" : False , \"smart_dashes\" : True , \"smart_quotes\" : False , \"smart_ellipses\" : True , } }","title":"Module pdocs.defaults"},{"location":"reference/pdocs/defaults/#variables","text":"HTML_OUTPUT_DIRECTORY MARKDOWN_EXTENSIONS MARKDOWN_EXTENSION_CONFIGS MARKDOWN_OUTPUT_DIRECTORY SERVER_HOST SERVER_PORT","title":"Variables"},{"location":"reference/pdocs/doc/","text":"Module pdocs.doc View Source import ast import inspect import typing __pdoc__ = {} def _source ( obj ): \"\"\" Returns the source code of the Python object `obj` as a list of lines. This tries to extract the source from the special `__wrapped__` attribute if it exists. Otherwise, it falls back to `inspect.getsourcelines`. If neither works, then the empty list is returned. \"\"\" try : return inspect . getsourcelines ( obj . __wrapped__ )[ 0 ] except BaseException : pass try : return inspect . getsourcelines ( obj )[ 0 ] except Exception : return [] def _var_docstrings ( tree , module , cls = None , init = False ): \"\"\" Extracts variable docstrings given `tree` as the abstract syntax, `module` as a `pdoc.Module` containing `tree` and an option `cls` as a `pdoc.Class` corresponding to the tree. In particular, `cls` should be specified when extracting docstrings from a class or an `__init__` method. Finally, `init` should be `True` when searching the AST of an `__init__` method so that `_var_docstrings` will only accept variables starting with `self.` as instance variables. A dictionary mapping variable name to a `pdoc.Variable` object is returned. \"\"\" vs = {} children = list ( ast . iter_child_nodes ( tree )) for i , child in enumerate ( children ): if isinstance ( child , ast . Assign ) and len ( child . targets ) == 1 : if not init and isinstance ( child . targets [ 0 ], ast . Name ): name = child . targets [ 0 ] . id elif ( isinstance ( child . targets [ 0 ], ast . Attribute ) and isinstance ( child . targets [ 0 ] . value , ast . Name ) and child . targets [ 0 ] . value . id == \"self\" ): name = child . targets [ 0 ] . attr else : continue if not _is_exported ( name ) and name not in getattr ( module , \"__all__\" , []): continue docstring = \"\" if ( i + 1 < len ( children ) and isinstance ( children [ i + 1 ], ast . Expr ) and isinstance ( children [ i + 1 ] . value , ast . Str ) ): docstring = children [ i + 1 ] . value . s vs [ name ] = Variable ( name , module , docstring , cls = cls ) return vs def _is_exported ( ident_name ): \"\"\" Returns `True` if `ident_name` matches the export criteria for an identifier name. This should not be used by clients. Instead, use `pdoc.Module.is_public`. \"\"\" return not ident_name . startswith ( \"_\" ) def _is_method ( cls : typing . Type , method_name : str ) -> bool : \"\"\" Returns `True` if the given method is a regular method, i.e. it's neither annotated with @classmethod nor @staticmethod. \"\"\" func = getattr ( cls , method_name , None ) if inspect . ismethod ( func ): # If the function is already bound, it's a classmethod. # Regular methods are not bound before initialization. return False for c in inspect . getmro ( cls ): if method_name in c . __dict__ : return not isinstance ( c . __dict__ [ method_name ], staticmethod ) else : raise ValueError ( \"{method_name} not found in {cls}.\" . format ( method_name = method_name , cls = cls ) ) def _filter ( items , kind , attributes_set = (), attributes_not_set = (), sort = True ): items = ( item for item in items if isinstance ( item , kind )) for attribute_set in attributes_set : items = ( item for item in items if getattr ( item , attribute_set , False )) for attribute_not_set in attributes_not_set : items = ( item for item in items if not getattr ( item , attribute_not_set , False )) if sort : return sorted ( items ) else : return tuple ( items ) class Doc ( object ): \"\"\" A base class for all documentation objects. A documentation object corresponds to *something* in a Python module that has a docstring associated with it. Typically, this only includes modules, classes, functions and methods. However, `pdoc` adds support for extracting docstrings from the abstract syntax tree, which means that variables (module, class or instance) are supported too. A special type of documentation object `pdoc.External` is used to represent identifiers that are not part of the public interface of a module. (The name \"External\" is a bit of a misnomer, since it can also correspond to unexported members of the module, particularly in a class's ancestor list.) \"\"\" def __init__ ( self , name , module , docstring ): \"\"\" Initializes a documentation object, where `name` is the public identifier name, `module` is a `pdoc.Module` object, and `docstring` is a string containing the docstring for `name`. \"\"\" self . module = module \"\"\" The module documentation object that this object was defined in. \"\"\" self . name = name \"\"\" The identifier name for this object. \"\"\" self . docstring = inspect . cleandoc ( docstring or \"\" ) \"\"\" The docstring for this object. It has already been cleaned by `inspect.cleandoc`. \"\"\" @property def source ( self ): \"\"\" Returns the source code of the Python object `obj` as a list of lines. This tries to extract the source from the special `__wrapped__` attribute if it exists. Otherwise, it falls back to `inspect.getsourcelines`. If neither works, then the empty list is returned. \"\"\" raise NotImplementedError ( \"source() method should be implemented by sub casses\" ) @property def refname ( self ): \"\"\" Returns an appropriate reference name for this documentation object. Usually this is its fully qualified path. Every documentation object must provide this property. e.g., The refname for this property is <code>pdoc.Doc.refname</code>. \"\"\" raise NotImplementedError ( \"refname() method should be implemented by sub casses\" ) def __lt__ ( self , other ): return self . name < other . name def is_empty ( self ): \"\"\" Returns true if the docstring for this object is empty. \"\"\" return len ( self . docstring . strip ()) == 0 class Module ( Doc ): \"\"\" Representation of a module's documentation. \"\"\" __pdoc__ [ \"Module.module\" ] = \"The Python module object.\" __pdoc__ [ \"Module.name\" ] = \"\"\" The name of this module with respect to the context in which it was imported. It is always an absolute import path. \"\"\" def __init__ ( self , name , module , parent ): \"\"\" Creates a `Module` documentation object given the actual module Python object. \"\"\" super () . __init__ ( name , module , inspect . getdoc ( module )) self . parent = parent self . doc = {} \"\"\"A mapping from identifier name to a documentation object.\"\"\" self . refdoc = {} \"\"\" The same as `pdoc.Module.doc`, but maps fully qualified identifier names to documentation objects. \"\"\" self . submodules = [] vardocs = {} try : tree = ast . parse ( inspect . getsource ( self . module )) vardocs = _var_docstrings ( tree , self , cls = None ) except BaseException : pass self . _declared_variables = vardocs . keys () public = self . __public_objs () for name , obj in public . items (): # Skip any identifiers that already have doco. if name in self . doc and not self . doc [ name ] . is_empty (): continue # Functions and some weird builtins?, plus methods, classes, # modules and module level variables. if inspect . isroutine ( obj ): self . doc [ name ] = Function ( name , self , obj ) elif inspect . isclass ( obj ): self . doc [ name ] = Class ( name , self , obj ) elif name in vardocs : self . doc [ name ] = vardocs [ name ] else : # Catch all for variables. self . doc [ name ] = Variable ( name , self , \"\" , cls = None ) # Now see if we can grab inheritance relationships between classes. for docobj in self . doc . values (): if isinstance ( docobj , Class ): docobj . _fill_inheritance () # Build the reference name dictionary. for _basename , docobj in self . doc . items (): self . refdoc [ docobj . refname ] = docobj if isinstance ( docobj , Class ): for v in docobj . class_variables (): self . refdoc [ v . refname ] = v for v in docobj . instance_variables (): self . refdoc [ v . refname ] = v for f in docobj . methods (): self . refdoc [ f . refname ] = f for f in docobj . functions (): self . refdoc [ f . refname ] = f # Finally look for more docstrings in the __pdoc__ override. for name , docstring in getattr ( self . module , \"__pdoc__\" , {}) . items (): refname = \" %s . %s \" % ( self . refname , name ) if docstring is None : self . doc . pop ( name , None ) self . refdoc . pop ( refname , None ) continue dobj = self . find_ident ( refname ) if isinstance ( dobj , External ): continue dobj . docstring = inspect . cleandoc ( docstring ) @property def source ( self ): return _source ( self . module ) @property def refname ( self ): return self . name @property def is_namespace ( self ): \"\"\"Returns `True` if this module represents a [namespace package](https://packaging.python.org/guides/packaging-namespace-packages/). \"\"\" return self . module . __spec__ . origin in ( None , \"namespace\" ) def mro ( self , cls ): \"\"\" Returns a method resolution list of ancestor documentation objects for `cls`, which must be a documentation object. The list will contain objects belonging to `pdoc.Class` or `pdoc.External`. Objects belonging to the former are exported classes either in this module or in one of its sub-modules. \"\"\" return [ self . find_class ( c ) for c in inspect . getmro ( cls . cls ) if c not in ( cls . cls , object )] def descendents ( self , cls ): \"\"\" Returns a descendent list of documentation objects for `cls`, which must be a documentation object. The list will contain objects belonging to `pdoc.Class` or `pdoc.External`. Objects belonging to the former are exported classes either in this module or in one of its sub-modules. \"\"\" if cls . cls == type or not hasattr ( cls . cls , \"__subclasses__\" ): # Is this right? return [] downs = cls . cls . __subclasses__ () return list ( map ( lambda c : self . find_class ( c ), downs )) def is_public ( self , name ): \"\"\" Returns `True` if and only if an identifier with name `name` is part of the public interface of this module. While the names of sub-modules are included, identifiers only exported by sub-modules are not checked. `name` should be a fully qualified name, e.g., <code>pdoc.Module.is_public</code>. \"\"\" return name in self . refdoc def find_class ( self , cls ): \"\"\" Given a Python `cls` object, try to find it in this module or in any of the exported identifiers of the submodules. \"\"\" for doc_cls in self . classes (): if cls is doc_cls . cls : return doc_cls for module in self . submodules : doc_cls = module . find_class ( cls ) if not isinstance ( doc_cls , External ): return doc_cls return External ( \" %s . %s \" % ( cls . __module__ , cls . __name__ )) def find_ident ( self , name , _seen = None ): \"\"\" Searches this module and **all** of its sub/super-modules for an identifier with name `name` in its list of exported identifiers according to `pdoc`. Note that unexported sub-modules are searched. A bare identifier (without `.` separators) will only be checked for in this module. The documentation object corresponding to the identifier is returned. If one cannot be found, then an instance of `External` is returned populated with the given identifier. \"\"\" _seen = _seen or set () if self in _seen : return None _seen . add ( self ) if name == self . refname : return self if name in self . refdoc : return self . refdoc [ name ] for module in self . submodules : o = module . find_ident ( name , _seen = _seen ) if not isinstance ( o , ( External , type ( None ))): return o # Traverse also up-level super-modules module = self . parent while module is not None : o = module . find_ident ( name , _seen = _seen ) if not isinstance ( o , ( External , type ( None ))): return o module = module . parent return External ( name ) def variables ( self ): \"\"\" Returns all documented module level variables in the module sorted alphabetically as a list of `pdoc.Variable`. \"\"\" return _filter ( self . doc . values (), Variable ) def classes ( self ): \"\"\" Returns all documented module level classes in the module sorted alphabetically as a list of `pdoc.Class`. \"\"\" return _filter ( self . doc . values (), Class ) def functions ( self ): \"\"\" Returns all documented module level functions in the module sorted alphabetically as a list of `pdoc.Function`. \"\"\" return _filter ( self . doc . values (), Function ) def __is_exported ( self , name , module ): \"\"\" Returns `True` if and only if `pdoc` considers `name` to be a public identifier for this module where `name` was defined in the Python module `module`. If this module has an `__all__` attribute, then `name` is considered to be exported if and only if it is a member of this module's `__all__` list. If `__all__` is not set, then whether `name` is exported or not is heuristically determined. Firstly, if `name` starts with an underscore, it will not be considered exported. Secondly, if `name` was defined in a module other than this one, it will not be considered exported. In all other cases, `name` will be considered exported. \"\"\" if hasattr ( self . module , \"__all__\" ): return name in self . module . __all__ if not _is_exported ( name ): return False if module is not None and self . module . __name__ != module . __name__ : return name in self . _declared_variables return True def __public_objs ( self ): \"\"\" Returns a dictionary mapping a public identifier name to a Python object. \"\"\" members = dict ( inspect . getmembers ( self . module )) return dict ( [ ( name , obj ) for name , obj in members . items () if self . __is_exported ( name , inspect . getmodule ( obj )) ] ) def allmodules ( self ): yield self for i in self . submodules : yield from i . allmodules () def toroot ( self ): n = self while n : yield n n = n . parent class Class ( Doc ): \"\"\" Representation of a class's documentation. \"\"\" def __init__ ( self , name , module , class_obj ): \"\"\" Same as `pdocs.Doc.__init__`, except `class_obj` must be a Python class object. The docstring is gathered automatically. \"\"\" super () . __init__ ( name , module , inspect . getdoc ( class_obj )) self . cls = class_obj \"\"\"The class Python object.\"\"\" self . doc = {} \"\"\"A mapping from identifier name to a `pdoc.Doc` objects.\"\"\" self . doc_init = {} \"\"\" A special version of `pdoc.Class.doc` that contains documentation for instance variables found in the `__init__` method. \"\"\" public = self . __public_objs () try : # First try and find docstrings for class variables. # Then move on to finding docstrings for instance variables. # This must be optional, since not all modules have source # code available. cls_ast = ast . parse ( inspect . getsource ( self . cls )) . body [ 0 ] self . doc = _var_docstrings ( cls_ast , self . module , cls = self ) for n in cls_ast . body if \"__init__\" in public else []: if isinstance ( n , ast . FunctionDef ) and n . name == \"__init__\" : self . doc_init = _var_docstrings ( n , self . module , cls = self , init = True ) break except BaseException : pass # Convert the public Python objects to documentation objects. for name , obj in public . items (): # Skip any identifiers that already have doco. if name in self . doc and not self . doc [ name ] . is_empty (): continue if name in self . doc_init : # Let instance members override class members. continue if inspect . isroutine ( obj ): self . doc [ name ] = Function ( name , self . module , obj , cls = self , method = _is_method ( self . cls , name ) ) elif isinstance ( obj , property ): docstring = getattr ( obj , \"__doc__\" , \"\" ) self . doc_init [ name ] = Variable ( name , self . module , docstring , cls = self ) elif not inspect . isbuiltin ( obj ) and not inspect . isroutine ( obj ): if name in getattr ( self . cls , \"__slots__\" , []): self . doc_init [ name ] = Variable ( name , self . module , \"\" , cls = self ) else : self . doc [ name ] = Variable ( name , self . module , \"\" , cls = self ) @property def source ( self ): return _source ( self . cls ) @property def refname ( self ): return \" %s . %s \" % ( self . module . refname , self . cls . __name__ ) def class_variables ( self ): \"\"\" Returns all documented class variables in the class, sorted alphabetically as a list of `pdoc.Variable`. \"\"\" return _filter ( self . doc . values (), Variable ) def instance_variables ( self ): \"\"\" Returns all instance variables in the class, sorted alphabetically as a list of `pdoc.Variable`. Instance variables are attributes of `self` defined in a class's `__init__` method. \"\"\" return _filter ( self . doc_init . values (), Variable ) def methods ( self ): \"\"\" Returns all documented methods as `pdoc.Function` objects in the class, sorted alphabetically. Unfortunately, this also includes class methods. \"\"\" return _filter ( self . doc . values (), Function , attributes_set = ( \"method\" ,)) def functions ( self ): \"\"\" Returns all documented static functions as `pdoc.Function` objects in the class, sorted alphabetically. \"\"\" return _filter ( self . doc . values (), Function , attributes_not_set = ( \"method\" ,)) def params ( self ): \"\"\"Returns back the parameters for the classes __init__ method\"\"\" params = Function . _params ( self . cls . __init__ ) return params [ 1 :] if params [ 0 ] == \"self\" else params def _fill_inheritance ( self ): \"\"\" Traverses this class's ancestor list and attempts to fill in missing documentation from its ancestor's documentation. The first pass connects variables, methods and functions with their inherited couterparts. (The templates will decide how to display docstrings.) The second pass attempts to add instance variables to this class that were only explicitly declared in a parent class. This second pass is necessary since instance variables are only discoverable by traversing the abstract syntax tree. \"\"\" mro = [ c for c in self . module . mro ( self ) if c != self and isinstance ( c , Class )] def search ( d , fdoc ): for c in mro : doc = fdoc ( c ) if d . name in doc and isinstance ( d , type ( doc [ d . name ])): return doc [ d . name ] return None for fdoc in ( lambda c : c . doc_init , lambda c : c . doc ): for d in fdoc ( self ) . values (): dinherit = search ( d , fdoc ) if dinherit is not None : d . inherits = dinherit # Since instance variables aren't part of a class's members, # we need to manually deduce inheritance. Oh lawdy. for c in mro : for name in filter ( lambda n : n not in self . doc_init , c . doc_init ): d = c . doc_init [ name ] self . doc_init [ name ] = Variable ( d . name , d . module , \"\" , cls = self ) self . doc_init [ name ] . inherits = d def mro ( self ): \"\"\"Returns back the Method Resolution Order (MRO) for this class\"\"\" return [ self . module . find_class ( cls ) for cls in inspect . getmro ( self . cls ) if cls not in ( self . cls , object , self ) ] def subclasses ( self ): \"\"\"Returns back all subclasses of this class\"\"\" return [ self . module . find_class ( cls ) for cls in type . __subclasses__ ( self . cls )] def __public_objs ( self ): \"\"\" Returns a dictionary mapping a public identifier name to a Python object. This counts the `__init__` method as being public. \"\"\" _pdoc = getattr ( self . module . module , \"__pdoc__\" , {}) def forced_out ( name ): return _pdoc . get ( \" %s . %s \" % ( self . name , name ), False ) is None def exported ( name ): if _is_exported ( name ) and not forced_out ( name ): return name idents = dict ( inspect . getmembers ( self . cls )) return dict ([( n , o ) for n , o in idents . items () if exported ( n )]) class Function ( Doc ): \"\"\" Representation of documentation for a Python function or method. \"\"\" def __init__ ( self , name , module , func_obj , cls = None , method = False ): \"\"\" Same as `pdoc.Doc.__init__`, except `func_obj` must be a Python function object. The docstring is gathered automatically. `cls` should be set when this is a method or a static function beloing to a class. `cls` should be a `pdoc.Class` object. `method` should be `True` when the function is a method. In all other cases, it should be `False`. \"\"\" super () . __init__ ( name , module , inspect . getdoc ( func_obj )) self . func = func_obj \"\"\"The Python function object.\"\"\" self . cls = cls \"\"\" The `pdoc.Class` documentation object if this is a method. If not, this is None. \"\"\" self . method = method \"\"\" Whether this function is a method or not. In particular, static class methods have this set to False. \"\"\" @property def source ( self ): return _source ( self . func ) @property def refname ( self ): if self . cls is None : return \" %s . %s \" % ( self . module . refname , self . name ) else : return \" %s . %s \" % ( self . cls . refname , self . name ) def funcdef ( self ): \"\"\" Generates the string of keywords used to define the function, for example `def` or `async def`. \"\"\" keywords = [] if self . _is_async (): keywords . append ( \"async\" ) keywords . append ( \"def\" ) return \" \" . join ( keywords ) def _is_async ( self ): \"\"\" Returns whether is function is asynchronous, either as a coroutine or an async generator. \"\"\" try : # Both of these are required because coroutines aren't classified as # async generators and vice versa. return inspect . iscoroutinefunction ( self . func ) or inspect . isasyncgenfunction ( self . func ) except AttributeError : return False def spec ( self ): \"\"\" Returns a nicely formatted spec of the function's parameter list as a string. This includes argument lists, keyword arguments and default values. \"\"\" return \", \" . join ( self . params ()) @staticmethod def _signature ( function ): try : return inspect . signature ( function ) except ( TypeError , ValueError ): # We can't get a Python signature (likely C function) return False def return_annotation ( self ): \"\"\"Returns back return type annotation if a valid one is found\"\"\" signature = self . _signature ( self . func ) if not signature or signature . return_annotation == inspect . _empty : return \"\" return inspect . formatannotation ( signature . return_annotation ) def params ( self ): \"\"\" Returns a list where each element is a nicely formatted parameter of this function. This includes argument lists, keyword arguments and default values. \"\"\" return self . _params ( self . func ) @classmethod def _params ( cls , function ): \"\"\" Returns a list where each element is a nicely formatted parameter of this function. This includes argument lists, keyword arguments and default values. \"\"\" signature = cls . _signature ( function ) if not signature : return [ \"...\" ] # The following is taken almost verbatim from the Python stdlib # https://github.com/python/cpython/blob/3.6/Lib/inspect.py#L3017 # # This is done simply because it is hard to unstringify the result since commas could # be present beyond just between parameters. params = [] render_pos_only_separator = False render_kw_only_separator = True for param in signature . parameters . values (): kind = param . kind if kind == inspect . _POSITIONAL_ONLY : render_pos_only_separator = True elif render_pos_only_separator : params . append ( '/' ) render_pos_only_separator = False if kind == inspect . _VAR_POSITIONAL : render_kw_only_separator = False elif kind == inspect . _KEYWORD_ONLY and render_kw_only_separator : params . append ( '*' ) render_kw_only_separator = False params . append ( str ( param )) if render_pos_only_separator : params . append ( '/' ) return params def __lt__ ( self , other ): # Push __init__ to the top. if \"__init__\" in ( self . name , other . name ): return self . name != other . name and self . name == \"__init__\" else : return self . name < other . name class Variable ( Doc ): \"\"\" Representation of a variable's documentation. This includes module, class and instance variables. \"\"\" def __init__ ( self , name , module , docstring , cls = None ): \"\"\" Same as `pdoc.Doc.__init__`, except `cls` should be provided as a `pdoc.Class` object when this is a class or instance variable. \"\"\" super () . __init__ ( name , module , docstring ) self . cls = cls \"\"\" The `podc.Class` object if this is a class or instance variable. If not, this is None. \"\"\" @property def source ( self ): return [] @property def refname ( self ): if self . cls is None : return \" %s . %s \" % ( self . module . refname , self . name ) else : return \" %s . %s \" % ( self . cls . refname , self . name ) class External ( Doc ): \"\"\" A representation of an external identifier. The textual representation is the same as an internal identifier, but without any context. (Usually this makes linking more difficult.) External identifiers are also used to represent something that is not exported but appears somewhere in the public interface (like the ancestor list of a class). \"\"\" __pdoc__ [ \"External.docstring\" ] = \"\"\" An empty string. External identifiers do not have docstrings. \"\"\" __pdoc__ [ \"External.module\" ] = \"\"\" Always `None`. External identifiers have no associated `pdoc.Module`. \"\"\" __pdoc__ [ \"External.name\" ] = \"\"\" Always equivalent to `pdoc.External.refname` since external identifiers are always expressed in their fully qualified form. \"\"\" def __init__ ( self , name ): \"\"\" Initializes an external identifier with `name`, where `name` should be a fully qualified name. \"\"\" super () . __init__ ( name , None , \"\" ) @property def source ( self ): return [] @property def refname ( self ): return self . name Classes Class class ( name , module , class_obj ) Representation of a class's documentation. View Source class Class ( Doc ) : \"\"\" Representation of a class ' s documentation. \"\"\" def __init__ ( self , name , module , class_obj ) : \"\"\" Same as ` pdocs . Doc . __init__ `, except ` class_obj ` must be a Python class object . The docstring is gathered automatically . \"\"\" super () . __init__ ( name , module , inspect . getdoc ( class_obj )) self . cls = class_obj \"\"\" The class Python object. \"\"\" self . doc = {} \"\"\" A mapping from identifier name to a `pdoc.Doc` objects. \"\"\" self . doc_init = {} \"\"\" A special version of ` pdoc . Class . doc ` that contains documentation for instance variables found in the ` __init__ ` method . \"\"\" public = self . __public_objs () try : # First try and find docstrings for class variables . # Then move on to finding docstrings for instance variables . # This must be optional , since not all modules have source # code available . cls_ast = ast . parse ( inspect . getsource ( self . cls )) . body [ 0 ] self . doc = _var_docstrings ( cls_ast , self . module , cls = self ) for n in cls_ast . body if \" __init__ \" in public else []: if isinstance ( n , ast . FunctionDef ) and n . name == \" __init__ \" : self . doc_init = _var_docstrings ( n , self . module , cls = self , init = True ) break except BaseException : pass # Convert the public Python objects to documentation objects . for name , obj in public . items () : # Skip any identifiers that already have doco . if name in self . doc and not self . doc [ name ]. is_empty () : continue if name in self . doc_init : # Let instance members override class members . continue if inspect . isroutine ( obj ) : self . doc [ name ] = Function ( name , self . module , obj , cls = self , method = _is_method ( self . cls , name ) ) elif isinstance ( obj , property ) : docstring = getattr ( obj , \" __doc__ \" , \"\" ) self . doc_init [ name ] = Variable ( name , self . module , docstring , cls = self ) elif not inspect . isbuiltin ( obj ) and not inspect . isroutine ( obj ) : if name in getattr ( self . cls , \" __slots__ \" , [] ) : self . doc_init [ name ] = Variable ( name , self . module , \"\" , cls = self ) else : self . doc [ name ] = Variable ( name , self . module , \"\" , cls = self ) @ property def source ( self ) : return _source ( self . cls ) @ property def refname ( self ) : return \" %s.%s \" % ( self . module . refname , self . cls . __name__ ) def class_variables ( self ) : \"\"\" Returns all documented class variables in the class , sorted alphabetically as a list of ` pdoc . Variable `. \"\"\" return _filter ( self . doc . values () , Variable ) def instance_variables ( self ) : \"\"\" Returns all instance variables in the class , sorted alphabetically as a list of ` pdoc . Variable `. Instance variables are attributes of ` self ` defined in a class ' s `__init__` method . \"\"\" return _filter ( self . doc_init . values () , Variable ) def methods ( self ) : \"\"\" Returns all documented methods as ` pdoc . Function ` objects in the class , sorted alphabetically . Unfortunately , this also includes class methods . \"\"\" return _filter ( self . doc . values () , Function , attributes_set = ( \" method \" , )) def functions ( self ) : \"\"\" Returns all documented static functions as ` pdoc . Function ` objects in the class , sorted alphabetically . \"\"\" return _filter ( self . doc . values () , Function , attributes_not_set = ( \" method \" , )) def params ( self ) : \"\"\" Returns back the parameters for the classes __init__ method \"\"\" params = Function . _params ( self . cls . __init__ ) return params [ 1 :] if params [ 0 ] == \" self \" else params def _fill_inheritance ( self ) : \"\"\" Traverses this class ' s ancestor list and attempts to fill in missing documentation from its ancestor ' s documentation. The first pass connects variables , methods and functions with their inherited couterparts . ( The templates will decide how to display docstrings . ) The second pass attempts to add instance variables to this class that were only explicitly declared in a parent class . This second pass is necessary since instance variables are only discoverable by traversing the abstract syntax tree . \"\"\" mro = [ c for c in self . module . mro ( self ) if c != self and isinstance ( c , Class ) ] def search ( d , fdoc ) : for c in mro : doc = fdoc ( c ) if d . name in doc and isinstance ( d , type ( doc [ d . name ] )) : return doc [ d . name ] return None for fdoc in ( lambda c : c . doc_init , lambda c : c . doc ) : for d in fdoc ( self ) . values () : dinherit = search ( d , fdoc ) if dinherit is not None : d . inherits = dinherit # Since instance variables aren ' t part of a class ' s members , # we need to manually deduce inheritance . Oh lawdy . for c in mro : for name in filter ( lambda n : n not in self . doc_init , c . doc_init ) : d = c . doc_init [ name ] self . doc_init [ name ] = Variable ( d . name , d . module , \"\" , cls = self ) self . doc_init [ name ]. inherits = d def mro ( self ) : \"\"\" Returns back the Method Resolution Order (MRO) for this class \"\"\" return [ self . module . find_class ( cls ) for cls in inspect . getmro ( self . cls ) if cls not in ( self . cls , object , self ) ] def subclasses ( self ) : \"\"\" Returns back all subclasses of this class \"\"\" return [ self . module . find_class ( cls ) for cls in type . __subclasses__ ( self . cls ) ] def __public_objs ( self ) : \"\"\" Returns a dictionary mapping a public identifier name to a Python object . This counts the ` __init__ ` method as being public . \"\"\" _pdoc = getattr ( self . module . module , \" __pdoc__ \" , {} ) def forced_out ( name ) : return _pdoc . get ( \" %s.%s \" % ( self . name , name ) , False ) is None def exported ( name ) : if _is_exported ( name ) and not forced_out ( name ) : return name idents = dict ( inspect . getmembers ( self . cls )) return dict ( [ ( n , o ) for n , o in idents . items () if exported ( n ) ] ) Ancestors (in MRO) pdocs.doc.Doc Instance variables refname source Methods class_variables def ( self ) Returns all documented class variables in the class, sorted alphabetically as a list of pdoc.Variable . View Source def class_variables ( self ) : \"\"\" Returns all documented class variables in the class , sorted alphabetically as a list of ` pdoc . Variable `. \"\"\" return _filter ( self . doc . values () , Variable ) functions def ( self ) Returns all documented static functions as pdoc.Function objects in the class, sorted alphabetically. View Source def functions ( self ) : \"\"\" Returns all documented static functions as ` pdoc . Function ` objects in the class , sorted alphabetically . \"\"\" return _filter ( self . doc . values () , Function , attributes_not_set = ( \" method \" , )) instance_variables def ( self ) Returns all instance variables in the class, sorted alphabetically as a list of pdoc.Variable . Instance variables are attributes of self defined in a class's __init__ method. View Source def instance_variables ( self ) : \"\"\" Returns all instance variables in the class , sorted alphabetically as a list of ` pdoc . Variable `. Instance variables are attributes of ` self ` defined in a class ' s `__init__` method . \"\"\" return _filter ( self . doc_init . values () , Variable ) is_empty def ( self ) Returns true if the docstring for this object is empty. View Source def is_empty ( self ) : \"\"\" Returns true if the docstring for this object is empty . \"\"\" return len ( self . docstring . strip ()) == 0 methods def ( self ) Returns all documented methods as pdoc.Function objects in the class, sorted alphabetically. Unfortunately, this also includes class methods. View Source def methods ( self ) : \"\"\" Returns all documented methods as ` pdoc . Function ` objects in the class , sorted alphabetically . Unfortunately , this also includes class methods . \"\"\" return _filter ( self . doc . values () , Function , attributes_set = ( \" method \" , )) mro def ( self ) Returns back the Method Resolution Order (MRO) for this class View Source def mro ( self ) : \"\"\" Returns back the Method Resolution Order (MRO) for this class \"\"\" return [ self . module . find_class ( cls ) for cls in inspect . getmro ( self . cls ) if cls not in ( self . cls , object , self ) ] params def ( self ) Returns back the parameters for the classes init method View Source def params ( self ) : \"\"\" Returns back the parameters for the classes __init__ method \"\"\" params = Function . _params ( self . cls . __init__ ) return params [ 1 :] if params [ 0 ] == \" self \" else params subclasses def ( self ) Returns back all subclasses of this class View Source def subclasses ( self ) : \"\"\" Returns back all subclasses of this class \"\"\" return [ self . module . find_class ( cls ) for cls in type . __subclasses__ ( self . cls ) ] Doc class ( name , module , docstring ) A base class for all documentation objects. A documentation object corresponds to something in a Python module that has a docstring associated with it. Typically, this only includes modules, classes, functions and methods. However, pdoc adds support for extracting docstrings from the abstract syntax tree, which means that variables (module, class or instance) are supported too. A special type of documentation object pdoc.External is used to represent identifiers that are not part of the public interface of a module. (The name \"External\" is a bit of a misnomer, since it can also correspond to unexported members of the module, particularly in a class's ancestor list.) View Source class Doc ( object ) : \"\"\" A base class for all documentation objects . A documentation object corresponds to * something * in a Python module that has a docstring associated with it . Typically , this only includes modules , classes , functions and methods . However , ` pdoc ` adds support for extracting docstrings from the abstract syntax tree , which means that variables ( module , class or instance ) are supported too . A special type of documentation object ` pdoc . External ` is used to represent identifiers that are not part of the public interface of a module . ( The name \" External \" is a bit of a misnomer , since it can also correspond to unexported members of the module , particularly in a class ' s ancestor list.) \"\"\" def __init__ ( self , name , module , docstring ) : \"\"\" Initializes a documentation object , where ` name ` is the public identifier name , ` module ` is a ` pdoc . Module ` object , and ` docstring ` is a string containing the docstring for ` name `. \"\"\" self . module = module \"\"\" The module documentation object that this object was defined in . \"\"\" self . name = name \"\"\" The identifier name for this object . \"\"\" self . docstring = inspect . cleandoc ( docstring or \"\" ) \"\"\" The docstring for this object . It has already been cleaned by ` inspect . cleandoc `. \"\"\" @ property def source ( self ) : \"\"\" Returns the source code of the Python object ` obj ` as a list of lines . This tries to extract the source from the special ` __wrapped__ ` attribute if it exists . Otherwise , it falls back to ` inspect . getsourcelines `. If neither works , then the empty list is returned . \"\"\" raise NotImplementedError ( \" source() method should be implemented by sub casses \" ) @ property def refname ( self ) : \"\"\" Returns an appropriate reference name for this documentation object . Usually this is its fully qualified path . Every documentation object must provide this property . e . g ., The refname for this property is < code > pdoc . Doc . refname </ code > . \"\"\" raise NotImplementedError ( \" refname() method should be implemented by sub casses \" ) def __lt__ ( self , other ) : return self . name < other . name def is_empty ( self ) : \"\"\" Returns true if the docstring for this object is empty . \"\"\" return len ( self . docstring . strip ()) == 0 Descendants pdocs.doc.Module pdocs.doc.Class pdocs.doc.Function pdocs.doc.Variable pdocs.doc.External Instance variables refname Returns an appropriate reference name for this documentation object. Usually this is its fully qualified path. Every documentation object must provide this property. e.g., The refname for this property is pdoc.Doc.refname . source Returns the source code of the Python object obj as a list of lines. This tries to extract the source from the special __wrapped__ attribute if it exists. Otherwise, it falls back to inspect.getsourcelines . If neither works, then the empty list is returned. Methods is_empty def ( self ) Returns true if the docstring for this object is empty. View Source def is_empty ( self ) : \"\"\" Returns true if the docstring for this object is empty . \"\"\" return len ( self . docstring . strip ()) == 0 External class ( name ) A representation of an external identifier. The textual representation is the same as an internal identifier, but without any context. (Usually this makes linking more difficult.) External identifiers are also used to represent something that is not exported but appears somewhere in the public interface (like the ancestor list of a class). View Source class External ( Doc ) : \"\"\" A representation of an external identifier . The textual representation is the same as an internal identifier , but without any context . ( Usually this makes linking more difficult . ) External identifiers are also used to represent something that is not exported but appears somewhere in the public interface ( like the ancestor list of a class ) . \"\"\" __pdoc__ [ \" External.docstring \" ] = \"\"\" An empty string . External identifiers do not have docstrings . \"\"\" __pdoc__ [ \" External.module \" ] = \"\"\" Always ` None `. External identifiers have no associated ` pdoc . Module `. \"\"\" __pdoc__ [ \" External.name \" ] = \"\"\" Always equivalent to ` pdoc . External . refname ` since external identifiers are always expressed in their fully qualified form . \"\"\" def __init__ ( self , name ) : \"\"\" Initializes an external identifier with ` name `, where ` name ` should be a fully qualified name . \"\"\" super () . __init__ ( name , None , \"\" ) @ property def source ( self ) : return [] @ property def refname ( self ) : return self . name Ancestors (in MRO) pdocs.doc.Doc Instance variables refname source Methods is_empty def ( self ) Returns true if the docstring for this object is empty. View Source def is_empty ( self ) : \"\"\" Returns true if the docstring for this object is empty . \"\"\" return len ( self . docstring . strip ()) == 0 Function class ( name , module , func_obj , cls = None , method = False ) Representation of documentation for a Python function or method. View Source class Function ( Doc ) : \"\"\" Representation of documentation for a Python function or method . \"\"\" def __init__ ( self , name , module , func_obj , cls = None , method = False ) : \"\"\" Same as ` pdoc . Doc . __init__ `, except ` func_obj ` must be a Python function object . The docstring is gathered automatically . ` cls ` should be set when this is a method or a static function beloing to a class . ` cls ` should be a ` pdoc . Class ` object . ` method ` should be ` True ` when the function is a method . In all other cases , it should be ` False `. \"\"\" super () . __init__ ( name , module , inspect . getdoc ( func_obj )) self . func = func_obj \"\"\" The Python function object. \"\"\" self . cls = cls \"\"\" The ` pdoc . Class ` documentation object if this is a method . If not , this is None . \"\"\" self . method = method \"\"\" Whether this function is a method or not . In particular , static class methods have this set to False . \"\"\" @ property def source ( self ) : return _source ( self . func ) @ property def refname ( self ) : if self . cls is None : return \" %s.%s \" % ( self . module . refname , self . name ) else : return \" %s.%s \" % ( self . cls . refname , self . name ) def funcdef ( self ) : \"\"\" Generates the string of keywords used to define the function , for example ` def ` or ` async def `. \"\"\" keywords = [] if self . _is_async () : keywords . append ( \" async \" ) keywords . append ( \" def \" ) return \" \" . join ( keywords ) def _is_async ( self ) : \"\"\" Returns whether is function is asynchronous , either as a coroutine or an async generator . \"\"\" try : # Both of these are required because coroutines aren ' t classified as # async generators and vice versa . return inspect . iscoroutinefunction ( self . func ) or inspect . isasyncgenfunction ( self . func ) except AttributeError : return False def spec ( self ) : \"\"\" Returns a nicely formatted spec of the function ' s parameter list as a string . This includes argument lists , keyword arguments and default values . \"\"\" return \" , \" . join ( self . params ()) @ staticmethod def _signature ( function ) : try : return inspect . signature ( function ) except ( TypeError , ValueError ) : # We can ' t get a Python signature (likely C function) return False def return_annotation ( self ) : \"\"\" Returns back return type annotation if a valid one is found \"\"\" signature = self . _signature ( self . func ) if not signature or signature . return_annotation == inspect . _empty : return \"\" return inspect . formatannotation ( signature . return_annotation ) def params ( self ) : \"\"\" Returns a list where each element is a nicely formatted parameter of this function . This includes argument lists , keyword arguments and default values . \"\"\" return self . _params ( self . func ) @ classmethod def _params ( cls , function ) : \"\"\" Returns a list where each element is a nicely formatted parameter of this function . This includes argument lists , keyword arguments and default values . \"\"\" signature = cls . _signature ( function ) if not signature : return [ \" ... \" ] # The following is taken almost verbatim from the Python stdlib # https : // github . com / python / cpython / blob / 3 . 6 / Lib / inspect . py # L3017 # # This is done simply because it is hard to unstringify the result since commas could # be present beyond just between parameters . params = [] render_pos_only_separator = False render_kw_only_separator = True for param in signature . parameters . values () : kind = param . kind if kind == inspect . _POSITIONAL_ONLY : render_pos_only_separator = True elif render_pos_only_separator : params . append ( ' / ' ) render_pos_only_separator = False if kind == inspect . _VAR_POSITIONAL : render_kw_only_separator = False elif kind == inspect . _KEYWORD_ONLY and render_kw_only_separator : params . append ( ' * ' ) render_kw_only_separator = False params . append ( str ( param )) if render_pos_only_separator : params . append ( ' / ' ) return params def __lt__ ( self , other ) : # Push __init__ to the top . if \" __init__ \" in ( self . name , other . name ) : return self . name != other . name and self . name == \" __init__ \" else : return self . name < other . name Ancestors (in MRO) pdocs.doc.Doc Instance variables refname source Methods funcdef def ( self ) Generates the string of keywords used to define the function, for example def or async def . View Source def funcdef ( self ) : \"\"\" Generates the string of keywords used to define the function , for example ` def ` or ` async def `. \"\"\" keywords = [] if self . _is_async () : keywords . append ( \" async \" ) keywords . append ( \" def \" ) return \" \" . join ( keywords ) is_empty def ( self ) Returns true if the docstring for this object is empty. View Source def is_empty ( self ) : \"\"\" Returns true if the docstring for this object is empty . \"\"\" return len ( self . docstring . strip ()) == 0 params def ( self ) Returns a list where each element is a nicely formatted parameter of this function. This includes argument lists, keyword arguments and default values. View Source def params ( self ) : \"\"\" Returns a list where each element is a nicely formatted parameter of this function . This includes argument lists , keyword arguments and default values . \"\"\" return self . _params ( self . func ) return_annotation def ( self ) Returns back return type annotation if a valid one is found View Source def return_annotation ( self ) : \"\"\" Returns back return type annotation if a valid one is found \"\"\" signature = self . _signature ( self . func ) if not signature or signature . return_annotation == inspect . _empty : return \"\" return inspect . formatannotation ( signature . return_annotation ) spec def ( self ) Returns a nicely formatted spec of the function's parameter list as a string. This includes argument lists, keyword arguments and default values. View Source def spec ( self ) : \"\"\" Returns a nicely formatted spec of the function ' s parameter list as a string . This includes argument lists , keyword arguments and default values . \"\"\" return \" , \" . join ( self . params ()) Module class ( name , module , parent ) Representation of a module's documentation. View Source class Module ( Doc ): \"\"\" Representation of a module's documentation. \"\"\" __pdoc__ [ \"Module.module\" ] = \"The Python module object.\" __pdoc__ [ \"Module.name\" ] = \"\"\" The name of this module with respect to the context in which it was imported. It is always an absolute import path. \"\"\" def __init__ ( self , name , module , parent ): \"\"\" Creates a `Module` documentation object given the actual module Python object. \"\"\" super () . __init__ ( name , module , inspect . getdoc ( module )) self . parent = parent self . doc = {} \"\"\"A mapping from identifier name to a documentation object.\"\"\" self . refdoc = {} \"\"\" The same as `pdoc.Module.doc`, but maps fully qualified identifier names to documentation objects. \"\"\" self . submodules = [] vardocs = {} try : tree = ast . parse ( inspect . getsource ( self . module )) vardocs = _var_docstrings ( tree , self , cls = None ) except BaseException : pass self . _declared_variables = vardocs . keys () public = self . __public_objs () for name , obj in public . items (): # Skip any identifiers that already have doco. if name in self . doc and not self . doc [ name ] . is_empty (): continue # Functions and some weird builtins?, plus methods, classes, # modules and module level variables. if inspect . isroutine ( obj ): self . doc [ name ] = Function ( name , self , obj ) elif inspect . isclass ( obj ): self . doc [ name ] = Class ( name , self , obj ) elif name in vardocs : self . doc [ name ] = vardocs [ name ] else : # Catch all for variables. self . doc [ name ] = Variable ( name , self , \"\" , cls = None ) # Now see if we can grab inheritance relationships between classes. for docobj in self . doc . values (): if isinstance ( docobj , Class ): docobj . _fill_inheritance () # Build the reference name dictionary. for _basename , docobj in self . doc . items (): self . refdoc [ docobj . refname ] = docobj if isinstance ( docobj , Class ): for v in docobj . class_variables (): self . refdoc [ v . refname ] = v for v in docobj . instance_variables (): self . refdoc [ v . refname ] = v for f in docobj . methods (): self . refdoc [ f . refname ] = f for f in docobj . functions (): self . refdoc [ f . refname ] = f # Finally look for more docstrings in the __pdoc__ override. for name , docstring in getattr ( self . module , \"__pdoc__\" , {}) . items (): refname = \" %s . %s \" % ( self . refname , name ) if docstring is None : self . doc . pop ( name , None ) self . refdoc . pop ( refname , None ) continue dobj = self . find_ident ( refname ) if isinstance ( dobj , External ): continue dobj . docstring = inspect . cleandoc ( docstring ) @property def source ( self ): return _source ( self . module ) @property def refname ( self ): return self . name @property def is_namespace ( self ): \"\"\"Returns `True` if this module represents a [namespace package](https://packaging.python.org/guides/packaging-namespace-packages/). \"\"\" return self . module . __spec__ . origin in ( None , \"namespace\" ) def mro ( self , cls ): \"\"\" Returns a method resolution list of ancestor documentation objects for `cls`, which must be a documentation object. The list will contain objects belonging to `pdoc.Class` or `pdoc.External`. Objects belonging to the former are exported classes either in this module or in one of its sub-modules. \"\"\" return [ self . find_class ( c ) for c in inspect . getmro ( cls . cls ) if c not in ( cls . cls , object )] def descendents ( self , cls ): \"\"\" Returns a descendent list of documentation objects for `cls`, which must be a documentation object. The list will contain objects belonging to `pdoc.Class` or `pdoc.External`. Objects belonging to the former are exported classes either in this module or in one of its sub-modules. \"\"\" if cls . cls == type or not hasattr ( cls . cls , \"__subclasses__\" ): # Is this right? return [] downs = cls . cls . __subclasses__ () return list ( map ( lambda c : self . find_class ( c ), downs )) def is_public ( self , name ): \"\"\" Returns `True` if and only if an identifier with name `name` is part of the public interface of this module. While the names of sub-modules are included, identifiers only exported by sub-modules are not checked. `name` should be a fully qualified name, e.g., <code>pdoc.Module.is_public</code>. \"\"\" return name in self . refdoc def find_class ( self , cls ): \"\"\" Given a Python `cls` object, try to find it in this module or in any of the exported identifiers of the submodules. \"\"\" for doc_cls in self . classes (): if cls is doc_cls . cls : return doc_cls for module in self . submodules : doc_cls = module . find_class ( cls ) if not isinstance ( doc_cls , External ): return doc_cls return External ( \" %s . %s \" % ( cls . __module__ , cls . __name__ )) def find_ident ( self , name , _seen = None ): \"\"\" Searches this module and **all** of its sub/super-modules for an identifier with name `name` in its list of exported identifiers according to `pdoc`. Note that unexported sub-modules are searched. A bare identifier (without `.` separators) will only be checked for in this module. The documentation object corresponding to the identifier is returned. If one cannot be found, then an instance of `External` is returned populated with the given identifier. \"\"\" _seen = _seen or set () if self in _seen : return None _seen . add ( self ) if name == self . refname : return self if name in self . refdoc : return self . refdoc [ name ] for module in self . submodules : o = module . find_ident ( name , _seen = _seen ) if not isinstance ( o , ( External , type ( None ))): return o # Traverse also up-level super-modules module = self . parent while module is not None : o = module . find_ident ( name , _seen = _seen ) if not isinstance ( o , ( External , type ( None ))): return o module = module . parent return External ( name ) def variables ( self ): \"\"\" Returns all documented module level variables in the module sorted alphabetically as a list of `pdoc.Variable`. \"\"\" return _filter ( self . doc . values (), Variable ) def classes ( self ): \"\"\" Returns all documented module level classes in the module sorted alphabetically as a list of `pdoc.Class`. \"\"\" return _filter ( self . doc . values (), Class ) def functions ( self ): \"\"\" Returns all documented module level functions in the module sorted alphabetically as a list of `pdoc.Function`. \"\"\" return _filter ( self . doc . values (), Function ) def __is_exported ( self , name , module ): \"\"\" Returns `True` if and only if `pdoc` considers `name` to be a public identifier for this module where `name` was defined in the Python module `module`. If this module has an `__all__` attribute, then `name` is considered to be exported if and only if it is a member of this module's `__all__` list. If `__all__` is not set, then whether `name` is exported or not is heuristically determined. Firstly, if `name` starts with an underscore, it will not be considered exported. Secondly, if `name` was defined in a module other than this one, it will not be considered exported. In all other cases, `name` will be considered exported. \"\"\" if hasattr ( self . module , \"__all__\" ): return name in self . module . __all__ if not _is_exported ( name ): return False if module is not None and self . module . __name__ != module . __name__ : return name in self . _declared_variables return True def __public_objs ( self ): \"\"\" Returns a dictionary mapping a public identifier name to a Python object. \"\"\" members = dict ( inspect . getmembers ( self . module )) return dict ( [ ( name , obj ) for name , obj in members . items () if self . __is_exported ( name , inspect . getmodule ( obj )) ] ) def allmodules ( self ): yield self for i in self . submodules : yield from i . allmodules () def toroot ( self ): n = self while n : yield n n = n . parent Ancestors (in MRO) pdocs.doc.Doc Instance variables is_namespace Returns True if this module represents a namespace package . refname source Methods allmodules def ( self ) View Source def allmodules ( self ) : yield self for i in self . submodules : yield from i . allmodules () classes def ( self ) Returns all documented module level classes in the module sorted alphabetically as a list of pdoc.Class . View Source def classes ( self ) : \"\"\" Returns all documented module level classes in the module sorted alphabetically as a list of ` pdoc . Class `. \"\"\" return _filter ( self . doc . values () , Class ) descendents def ( self , cls ) Returns a descendent list of documentation objects for cls , which must be a documentation object. The list will contain objects belonging to pdoc.Class or pdoc.External . Objects belonging to the former are exported classes either in this module or in one of its sub-modules. View Source def descendents ( self , cls ) : \"\"\" Returns a descendent list of documentation objects for ` cls `, which must be a documentation object . The list will contain objects belonging to ` pdoc . Class ` or ` pdoc . External `. Objects belonging to the former are exported classes either in this module or in one of its sub - modules . \"\"\" if cls . cls == type or not hasattr ( cls . cls , \" __subclasses__ \" ) : # Is this right ? return [] downs = cls . cls . __subclasses__ () return list ( map ( lambda c : self . find_class ( c ) , downs )) find_class def ( self , cls ) Given a Python cls object, try to find it in this module or in any of the exported identifiers of the submodules. View Source def find_class ( self , cls ) : \"\"\" Given a Python ` cls ` object , try to find it in this module or in any of the exported identifiers of the submodules . \"\"\" for doc_cls in self . classes () : if cls is doc_cls . cls : return doc_cls for module in self . submodules : doc_cls = module . find_class ( cls ) if not isinstance ( doc_cls , External ) : return doc_cls return External ( \" %s.%s \" % ( cls . __module__ , cls . __name__ )) find_ident def ( self , name , _seen = None ) Searches this module and all of its sub/super-modules for an identifier with name name in its list of exported identifiers according to pdoc . Note that unexported sub-modules are searched. A bare identifier (without . separators) will only be checked for in this module. The documentation object corresponding to the identifier is returned. If one cannot be found, then an instance of External is returned populated with the given identifier. View Source def find_ident ( self , name , _seen = None ) : \"\"\" Searches this module and ** all ** of its sub / super - modules for an identifier with name ` name ` in its list of exported identifiers according to ` pdoc `. Note that unexported sub - modules are searched . A bare identifier ( without `.` separators ) will only be checked for in this module . The documentation object corresponding to the identifier is returned . If one cannot be found , then an instance of ` External ` is returned populated with the given identifier . \"\"\" _seen = _seen or set () if self in _seen : return None _seen . add ( self ) if name == self . refname : return self if name in self . refdoc : return self . refdoc [ name ] for module in self . submodules : o = module . find_ident ( name , _seen = _seen ) if not isinstance ( o , ( External , type ( None ))) : return o # Traverse also up - level super - modules module = self . parent while module is not None : o = module . find_ident ( name , _seen = _seen ) if not isinstance ( o , ( External , type ( None ))) : return o module = module . parent return External ( name ) functions def ( self ) Returns all documented module level functions in the module sorted alphabetically as a list of pdoc.Function . View Source def functions ( self ) : \"\"\" Returns all documented module level functions in the module sorted alphabetically as a list of ` pdoc . Function `. \"\"\" return _filter ( self . doc . values () , Function ) is_empty def ( self ) Returns true if the docstring for this object is empty. View Source def is_empty ( self ) : \"\"\" Returns true if the docstring for this object is empty . \"\"\" return len ( self . docstring . strip ()) == 0 is_public def ( self , name ) Returns True if and only if an identifier with name name is part of the public interface of this module. While the names of sub-modules are included, identifiers only exported by sub-modules are not checked. name should be a fully qualified name, e.g., pdoc.Module.is_public . View Source def is_public ( self , name ) : \"\"\" Returns ` True ` if and only if an identifier with name ` name ` is part of the public interface of this module . While the names of sub - modules are included , identifiers only exported by sub - modules are not checked . ` name ` should be a fully qualified name , e . g ., < code > pdoc . Module . is_public </ code > . \"\"\" return name in self . refdoc mro def ( self , cls ) Returns a method resolution list of ancestor documentation objects for cls , which must be a documentation object. The list will contain objects belonging to pdoc.Class or pdoc.External . Objects belonging to the former are exported classes either in this module or in one of its sub-modules. View Source def mro ( self , cls ) : \"\"\" Returns a method resolution list of ancestor documentation objects for ` cls `, which must be a documentation object . The list will contain objects belonging to ` pdoc . Class ` or ` pdoc . External `. Objects belonging to the former are exported classes either in this module or in one of its sub - modules . \"\"\" return [ self . find_class ( c ) for c in inspect . getmro ( cls . cls ) if c not in ( cls . cls , object ) ] toroot def ( self ) View Source def toroot ( self ) : n = self while n : yield n n = n . parent variables def ( self ) Returns all documented module level variables in the module sorted alphabetically as a list of pdoc.Variable . View Source def variables ( self ) : \"\"\" Returns all documented module level variables in the module sorted alphabetically as a list of ` pdoc . Variable `. \"\"\" return _filter ( self . doc . values () , Variable ) Variable class ( name , module , docstring , cls = None ) Representation of a variable's documentation. This includes module, class and instance variables. View Source class Variable ( Doc ) : \"\"\" Representation of a variable ' s documentation. This includes module , class and instance variables . \"\"\" def __init__ ( self , name , module , docstring , cls = None ) : \"\"\" Same as ` pdoc . Doc . __init__ `, except ` cls ` should be provided as a ` pdoc . Class ` object when this is a class or instance variable . \"\"\" super () . __init__ ( name , module , docstring ) self . cls = cls \"\"\" The ` podc . Class ` object if this is a class or instance variable . If not , this is None . \"\"\" @ property def source ( self ) : return [] @ property def refname ( self ) : if self . cls is None : return \" %s.%s \" % ( self . module . refname , self . name ) else : return \" %s.%s \" % ( self . cls . refname , self . name ) Ancestors (in MRO) pdocs.doc.Doc Instance variables refname source Methods is_empty def ( self ) Returns true if the docstring for this object is empty. View Source def is_empty ( self ) : \"\"\" Returns true if the docstring for this object is empty . \"\"\" return len ( self . docstring . strip ()) == 0","title":"Doc"},{"location":"reference/pdocs/doc/#module-pdocsdoc","text":"View Source import ast import inspect import typing __pdoc__ = {} def _source ( obj ): \"\"\" Returns the source code of the Python object `obj` as a list of lines. This tries to extract the source from the special `__wrapped__` attribute if it exists. Otherwise, it falls back to `inspect.getsourcelines`. If neither works, then the empty list is returned. \"\"\" try : return inspect . getsourcelines ( obj . __wrapped__ )[ 0 ] except BaseException : pass try : return inspect . getsourcelines ( obj )[ 0 ] except Exception : return [] def _var_docstrings ( tree , module , cls = None , init = False ): \"\"\" Extracts variable docstrings given `tree` as the abstract syntax, `module` as a `pdoc.Module` containing `tree` and an option `cls` as a `pdoc.Class` corresponding to the tree. In particular, `cls` should be specified when extracting docstrings from a class or an `__init__` method. Finally, `init` should be `True` when searching the AST of an `__init__` method so that `_var_docstrings` will only accept variables starting with `self.` as instance variables. A dictionary mapping variable name to a `pdoc.Variable` object is returned. \"\"\" vs = {} children = list ( ast . iter_child_nodes ( tree )) for i , child in enumerate ( children ): if isinstance ( child , ast . Assign ) and len ( child . targets ) == 1 : if not init and isinstance ( child . targets [ 0 ], ast . Name ): name = child . targets [ 0 ] . id elif ( isinstance ( child . targets [ 0 ], ast . Attribute ) and isinstance ( child . targets [ 0 ] . value , ast . Name ) and child . targets [ 0 ] . value . id == \"self\" ): name = child . targets [ 0 ] . attr else : continue if not _is_exported ( name ) and name not in getattr ( module , \"__all__\" , []): continue docstring = \"\" if ( i + 1 < len ( children ) and isinstance ( children [ i + 1 ], ast . Expr ) and isinstance ( children [ i + 1 ] . value , ast . Str ) ): docstring = children [ i + 1 ] . value . s vs [ name ] = Variable ( name , module , docstring , cls = cls ) return vs def _is_exported ( ident_name ): \"\"\" Returns `True` if `ident_name` matches the export criteria for an identifier name. This should not be used by clients. Instead, use `pdoc.Module.is_public`. \"\"\" return not ident_name . startswith ( \"_\" ) def _is_method ( cls : typing . Type , method_name : str ) -> bool : \"\"\" Returns `True` if the given method is a regular method, i.e. it's neither annotated with @classmethod nor @staticmethod. \"\"\" func = getattr ( cls , method_name , None ) if inspect . ismethod ( func ): # If the function is already bound, it's a classmethod. # Regular methods are not bound before initialization. return False for c in inspect . getmro ( cls ): if method_name in c . __dict__ : return not isinstance ( c . __dict__ [ method_name ], staticmethod ) else : raise ValueError ( \"{method_name} not found in {cls}.\" . format ( method_name = method_name , cls = cls ) ) def _filter ( items , kind , attributes_set = (), attributes_not_set = (), sort = True ): items = ( item for item in items if isinstance ( item , kind )) for attribute_set in attributes_set : items = ( item for item in items if getattr ( item , attribute_set , False )) for attribute_not_set in attributes_not_set : items = ( item for item in items if not getattr ( item , attribute_not_set , False )) if sort : return sorted ( items ) else : return tuple ( items ) class Doc ( object ): \"\"\" A base class for all documentation objects. A documentation object corresponds to *something* in a Python module that has a docstring associated with it. Typically, this only includes modules, classes, functions and methods. However, `pdoc` adds support for extracting docstrings from the abstract syntax tree, which means that variables (module, class or instance) are supported too. A special type of documentation object `pdoc.External` is used to represent identifiers that are not part of the public interface of a module. (The name \"External\" is a bit of a misnomer, since it can also correspond to unexported members of the module, particularly in a class's ancestor list.) \"\"\" def __init__ ( self , name , module , docstring ): \"\"\" Initializes a documentation object, where `name` is the public identifier name, `module` is a `pdoc.Module` object, and `docstring` is a string containing the docstring for `name`. \"\"\" self . module = module \"\"\" The module documentation object that this object was defined in. \"\"\" self . name = name \"\"\" The identifier name for this object. \"\"\" self . docstring = inspect . cleandoc ( docstring or \"\" ) \"\"\" The docstring for this object. It has already been cleaned by `inspect.cleandoc`. \"\"\" @property def source ( self ): \"\"\" Returns the source code of the Python object `obj` as a list of lines. This tries to extract the source from the special `__wrapped__` attribute if it exists. Otherwise, it falls back to `inspect.getsourcelines`. If neither works, then the empty list is returned. \"\"\" raise NotImplementedError ( \"source() method should be implemented by sub casses\" ) @property def refname ( self ): \"\"\" Returns an appropriate reference name for this documentation object. Usually this is its fully qualified path. Every documentation object must provide this property. e.g., The refname for this property is <code>pdoc.Doc.refname</code>. \"\"\" raise NotImplementedError ( \"refname() method should be implemented by sub casses\" ) def __lt__ ( self , other ): return self . name < other . name def is_empty ( self ): \"\"\" Returns true if the docstring for this object is empty. \"\"\" return len ( self . docstring . strip ()) == 0 class Module ( Doc ): \"\"\" Representation of a module's documentation. \"\"\" __pdoc__ [ \"Module.module\" ] = \"The Python module object.\" __pdoc__ [ \"Module.name\" ] = \"\"\" The name of this module with respect to the context in which it was imported. It is always an absolute import path. \"\"\" def __init__ ( self , name , module , parent ): \"\"\" Creates a `Module` documentation object given the actual module Python object. \"\"\" super () . __init__ ( name , module , inspect . getdoc ( module )) self . parent = parent self . doc = {} \"\"\"A mapping from identifier name to a documentation object.\"\"\" self . refdoc = {} \"\"\" The same as `pdoc.Module.doc`, but maps fully qualified identifier names to documentation objects. \"\"\" self . submodules = [] vardocs = {} try : tree = ast . parse ( inspect . getsource ( self . module )) vardocs = _var_docstrings ( tree , self , cls = None ) except BaseException : pass self . _declared_variables = vardocs . keys () public = self . __public_objs () for name , obj in public . items (): # Skip any identifiers that already have doco. if name in self . doc and not self . doc [ name ] . is_empty (): continue # Functions and some weird builtins?, plus methods, classes, # modules and module level variables. if inspect . isroutine ( obj ): self . doc [ name ] = Function ( name , self , obj ) elif inspect . isclass ( obj ): self . doc [ name ] = Class ( name , self , obj ) elif name in vardocs : self . doc [ name ] = vardocs [ name ] else : # Catch all for variables. self . doc [ name ] = Variable ( name , self , \"\" , cls = None ) # Now see if we can grab inheritance relationships between classes. for docobj in self . doc . values (): if isinstance ( docobj , Class ): docobj . _fill_inheritance () # Build the reference name dictionary. for _basename , docobj in self . doc . items (): self . refdoc [ docobj . refname ] = docobj if isinstance ( docobj , Class ): for v in docobj . class_variables (): self . refdoc [ v . refname ] = v for v in docobj . instance_variables (): self . refdoc [ v . refname ] = v for f in docobj . methods (): self . refdoc [ f . refname ] = f for f in docobj . functions (): self . refdoc [ f . refname ] = f # Finally look for more docstrings in the __pdoc__ override. for name , docstring in getattr ( self . module , \"__pdoc__\" , {}) . items (): refname = \" %s . %s \" % ( self . refname , name ) if docstring is None : self . doc . pop ( name , None ) self . refdoc . pop ( refname , None ) continue dobj = self . find_ident ( refname ) if isinstance ( dobj , External ): continue dobj . docstring = inspect . cleandoc ( docstring ) @property def source ( self ): return _source ( self . module ) @property def refname ( self ): return self . name @property def is_namespace ( self ): \"\"\"Returns `True` if this module represents a [namespace package](https://packaging.python.org/guides/packaging-namespace-packages/). \"\"\" return self . module . __spec__ . origin in ( None , \"namespace\" ) def mro ( self , cls ): \"\"\" Returns a method resolution list of ancestor documentation objects for `cls`, which must be a documentation object. The list will contain objects belonging to `pdoc.Class` or `pdoc.External`. Objects belonging to the former are exported classes either in this module or in one of its sub-modules. \"\"\" return [ self . find_class ( c ) for c in inspect . getmro ( cls . cls ) if c not in ( cls . cls , object )] def descendents ( self , cls ): \"\"\" Returns a descendent list of documentation objects for `cls`, which must be a documentation object. The list will contain objects belonging to `pdoc.Class` or `pdoc.External`. Objects belonging to the former are exported classes either in this module or in one of its sub-modules. \"\"\" if cls . cls == type or not hasattr ( cls . cls , \"__subclasses__\" ): # Is this right? return [] downs = cls . cls . __subclasses__ () return list ( map ( lambda c : self . find_class ( c ), downs )) def is_public ( self , name ): \"\"\" Returns `True` if and only if an identifier with name `name` is part of the public interface of this module. While the names of sub-modules are included, identifiers only exported by sub-modules are not checked. `name` should be a fully qualified name, e.g., <code>pdoc.Module.is_public</code>. \"\"\" return name in self . refdoc def find_class ( self , cls ): \"\"\" Given a Python `cls` object, try to find it in this module or in any of the exported identifiers of the submodules. \"\"\" for doc_cls in self . classes (): if cls is doc_cls . cls : return doc_cls for module in self . submodules : doc_cls = module . find_class ( cls ) if not isinstance ( doc_cls , External ): return doc_cls return External ( \" %s . %s \" % ( cls . __module__ , cls . __name__ )) def find_ident ( self , name , _seen = None ): \"\"\" Searches this module and **all** of its sub/super-modules for an identifier with name `name` in its list of exported identifiers according to `pdoc`. Note that unexported sub-modules are searched. A bare identifier (without `.` separators) will only be checked for in this module. The documentation object corresponding to the identifier is returned. If one cannot be found, then an instance of `External` is returned populated with the given identifier. \"\"\" _seen = _seen or set () if self in _seen : return None _seen . add ( self ) if name == self . refname : return self if name in self . refdoc : return self . refdoc [ name ] for module in self . submodules : o = module . find_ident ( name , _seen = _seen ) if not isinstance ( o , ( External , type ( None ))): return o # Traverse also up-level super-modules module = self . parent while module is not None : o = module . find_ident ( name , _seen = _seen ) if not isinstance ( o , ( External , type ( None ))): return o module = module . parent return External ( name ) def variables ( self ): \"\"\" Returns all documented module level variables in the module sorted alphabetically as a list of `pdoc.Variable`. \"\"\" return _filter ( self . doc . values (), Variable ) def classes ( self ): \"\"\" Returns all documented module level classes in the module sorted alphabetically as a list of `pdoc.Class`. \"\"\" return _filter ( self . doc . values (), Class ) def functions ( self ): \"\"\" Returns all documented module level functions in the module sorted alphabetically as a list of `pdoc.Function`. \"\"\" return _filter ( self . doc . values (), Function ) def __is_exported ( self , name , module ): \"\"\" Returns `True` if and only if `pdoc` considers `name` to be a public identifier for this module where `name` was defined in the Python module `module`. If this module has an `__all__` attribute, then `name` is considered to be exported if and only if it is a member of this module's `__all__` list. If `__all__` is not set, then whether `name` is exported or not is heuristically determined. Firstly, if `name` starts with an underscore, it will not be considered exported. Secondly, if `name` was defined in a module other than this one, it will not be considered exported. In all other cases, `name` will be considered exported. \"\"\" if hasattr ( self . module , \"__all__\" ): return name in self . module . __all__ if not _is_exported ( name ): return False if module is not None and self . module . __name__ != module . __name__ : return name in self . _declared_variables return True def __public_objs ( self ): \"\"\" Returns a dictionary mapping a public identifier name to a Python object. \"\"\" members = dict ( inspect . getmembers ( self . module )) return dict ( [ ( name , obj ) for name , obj in members . items () if self . __is_exported ( name , inspect . getmodule ( obj )) ] ) def allmodules ( self ): yield self for i in self . submodules : yield from i . allmodules () def toroot ( self ): n = self while n : yield n n = n . parent class Class ( Doc ): \"\"\" Representation of a class's documentation. \"\"\" def __init__ ( self , name , module , class_obj ): \"\"\" Same as `pdocs.Doc.__init__`, except `class_obj` must be a Python class object. The docstring is gathered automatically. \"\"\" super () . __init__ ( name , module , inspect . getdoc ( class_obj )) self . cls = class_obj \"\"\"The class Python object.\"\"\" self . doc = {} \"\"\"A mapping from identifier name to a `pdoc.Doc` objects.\"\"\" self . doc_init = {} \"\"\" A special version of `pdoc.Class.doc` that contains documentation for instance variables found in the `__init__` method. \"\"\" public = self . __public_objs () try : # First try and find docstrings for class variables. # Then move on to finding docstrings for instance variables. # This must be optional, since not all modules have source # code available. cls_ast = ast . parse ( inspect . getsource ( self . cls )) . body [ 0 ] self . doc = _var_docstrings ( cls_ast , self . module , cls = self ) for n in cls_ast . body if \"__init__\" in public else []: if isinstance ( n , ast . FunctionDef ) and n . name == \"__init__\" : self . doc_init = _var_docstrings ( n , self . module , cls = self , init = True ) break except BaseException : pass # Convert the public Python objects to documentation objects. for name , obj in public . items (): # Skip any identifiers that already have doco. if name in self . doc and not self . doc [ name ] . is_empty (): continue if name in self . doc_init : # Let instance members override class members. continue if inspect . isroutine ( obj ): self . doc [ name ] = Function ( name , self . module , obj , cls = self , method = _is_method ( self . cls , name ) ) elif isinstance ( obj , property ): docstring = getattr ( obj , \"__doc__\" , \"\" ) self . doc_init [ name ] = Variable ( name , self . module , docstring , cls = self ) elif not inspect . isbuiltin ( obj ) and not inspect . isroutine ( obj ): if name in getattr ( self . cls , \"__slots__\" , []): self . doc_init [ name ] = Variable ( name , self . module , \"\" , cls = self ) else : self . doc [ name ] = Variable ( name , self . module , \"\" , cls = self ) @property def source ( self ): return _source ( self . cls ) @property def refname ( self ): return \" %s . %s \" % ( self . module . refname , self . cls . __name__ ) def class_variables ( self ): \"\"\" Returns all documented class variables in the class, sorted alphabetically as a list of `pdoc.Variable`. \"\"\" return _filter ( self . doc . values (), Variable ) def instance_variables ( self ): \"\"\" Returns all instance variables in the class, sorted alphabetically as a list of `pdoc.Variable`. Instance variables are attributes of `self` defined in a class's `__init__` method. \"\"\" return _filter ( self . doc_init . values (), Variable ) def methods ( self ): \"\"\" Returns all documented methods as `pdoc.Function` objects in the class, sorted alphabetically. Unfortunately, this also includes class methods. \"\"\" return _filter ( self . doc . values (), Function , attributes_set = ( \"method\" ,)) def functions ( self ): \"\"\" Returns all documented static functions as `pdoc.Function` objects in the class, sorted alphabetically. \"\"\" return _filter ( self . doc . values (), Function , attributes_not_set = ( \"method\" ,)) def params ( self ): \"\"\"Returns back the parameters for the classes __init__ method\"\"\" params = Function . _params ( self . cls . __init__ ) return params [ 1 :] if params [ 0 ] == \"self\" else params def _fill_inheritance ( self ): \"\"\" Traverses this class's ancestor list and attempts to fill in missing documentation from its ancestor's documentation. The first pass connects variables, methods and functions with their inherited couterparts. (The templates will decide how to display docstrings.) The second pass attempts to add instance variables to this class that were only explicitly declared in a parent class. This second pass is necessary since instance variables are only discoverable by traversing the abstract syntax tree. \"\"\" mro = [ c for c in self . module . mro ( self ) if c != self and isinstance ( c , Class )] def search ( d , fdoc ): for c in mro : doc = fdoc ( c ) if d . name in doc and isinstance ( d , type ( doc [ d . name ])): return doc [ d . name ] return None for fdoc in ( lambda c : c . doc_init , lambda c : c . doc ): for d in fdoc ( self ) . values (): dinherit = search ( d , fdoc ) if dinherit is not None : d . inherits = dinherit # Since instance variables aren't part of a class's members, # we need to manually deduce inheritance. Oh lawdy. for c in mro : for name in filter ( lambda n : n not in self . doc_init , c . doc_init ): d = c . doc_init [ name ] self . doc_init [ name ] = Variable ( d . name , d . module , \"\" , cls = self ) self . doc_init [ name ] . inherits = d def mro ( self ): \"\"\"Returns back the Method Resolution Order (MRO) for this class\"\"\" return [ self . module . find_class ( cls ) for cls in inspect . getmro ( self . cls ) if cls not in ( self . cls , object , self ) ] def subclasses ( self ): \"\"\"Returns back all subclasses of this class\"\"\" return [ self . module . find_class ( cls ) for cls in type . __subclasses__ ( self . cls )] def __public_objs ( self ): \"\"\" Returns a dictionary mapping a public identifier name to a Python object. This counts the `__init__` method as being public. \"\"\" _pdoc = getattr ( self . module . module , \"__pdoc__\" , {}) def forced_out ( name ): return _pdoc . get ( \" %s . %s \" % ( self . name , name ), False ) is None def exported ( name ): if _is_exported ( name ) and not forced_out ( name ): return name idents = dict ( inspect . getmembers ( self . cls )) return dict ([( n , o ) for n , o in idents . items () if exported ( n )]) class Function ( Doc ): \"\"\" Representation of documentation for a Python function or method. \"\"\" def __init__ ( self , name , module , func_obj , cls = None , method = False ): \"\"\" Same as `pdoc.Doc.__init__`, except `func_obj` must be a Python function object. The docstring is gathered automatically. `cls` should be set when this is a method or a static function beloing to a class. `cls` should be a `pdoc.Class` object. `method` should be `True` when the function is a method. In all other cases, it should be `False`. \"\"\" super () . __init__ ( name , module , inspect . getdoc ( func_obj )) self . func = func_obj \"\"\"The Python function object.\"\"\" self . cls = cls \"\"\" The `pdoc.Class` documentation object if this is a method. If not, this is None. \"\"\" self . method = method \"\"\" Whether this function is a method or not. In particular, static class methods have this set to False. \"\"\" @property def source ( self ): return _source ( self . func ) @property def refname ( self ): if self . cls is None : return \" %s . %s \" % ( self . module . refname , self . name ) else : return \" %s . %s \" % ( self . cls . refname , self . name ) def funcdef ( self ): \"\"\" Generates the string of keywords used to define the function, for example `def` or `async def`. \"\"\" keywords = [] if self . _is_async (): keywords . append ( \"async\" ) keywords . append ( \"def\" ) return \" \" . join ( keywords ) def _is_async ( self ): \"\"\" Returns whether is function is asynchronous, either as a coroutine or an async generator. \"\"\" try : # Both of these are required because coroutines aren't classified as # async generators and vice versa. return inspect . iscoroutinefunction ( self . func ) or inspect . isasyncgenfunction ( self . func ) except AttributeError : return False def spec ( self ): \"\"\" Returns a nicely formatted spec of the function's parameter list as a string. This includes argument lists, keyword arguments and default values. \"\"\" return \", \" . join ( self . params ()) @staticmethod def _signature ( function ): try : return inspect . signature ( function ) except ( TypeError , ValueError ): # We can't get a Python signature (likely C function) return False def return_annotation ( self ): \"\"\"Returns back return type annotation if a valid one is found\"\"\" signature = self . _signature ( self . func ) if not signature or signature . return_annotation == inspect . _empty : return \"\" return inspect . formatannotation ( signature . return_annotation ) def params ( self ): \"\"\" Returns a list where each element is a nicely formatted parameter of this function. This includes argument lists, keyword arguments and default values. \"\"\" return self . _params ( self . func ) @classmethod def _params ( cls , function ): \"\"\" Returns a list where each element is a nicely formatted parameter of this function. This includes argument lists, keyword arguments and default values. \"\"\" signature = cls . _signature ( function ) if not signature : return [ \"...\" ] # The following is taken almost verbatim from the Python stdlib # https://github.com/python/cpython/blob/3.6/Lib/inspect.py#L3017 # # This is done simply because it is hard to unstringify the result since commas could # be present beyond just between parameters. params = [] render_pos_only_separator = False render_kw_only_separator = True for param in signature . parameters . values (): kind = param . kind if kind == inspect . _POSITIONAL_ONLY : render_pos_only_separator = True elif render_pos_only_separator : params . append ( '/' ) render_pos_only_separator = False if kind == inspect . _VAR_POSITIONAL : render_kw_only_separator = False elif kind == inspect . _KEYWORD_ONLY and render_kw_only_separator : params . append ( '*' ) render_kw_only_separator = False params . append ( str ( param )) if render_pos_only_separator : params . append ( '/' ) return params def __lt__ ( self , other ): # Push __init__ to the top. if \"__init__\" in ( self . name , other . name ): return self . name != other . name and self . name == \"__init__\" else : return self . name < other . name class Variable ( Doc ): \"\"\" Representation of a variable's documentation. This includes module, class and instance variables. \"\"\" def __init__ ( self , name , module , docstring , cls = None ): \"\"\" Same as `pdoc.Doc.__init__`, except `cls` should be provided as a `pdoc.Class` object when this is a class or instance variable. \"\"\" super () . __init__ ( name , module , docstring ) self . cls = cls \"\"\" The `podc.Class` object if this is a class or instance variable. If not, this is None. \"\"\" @property def source ( self ): return [] @property def refname ( self ): if self . cls is None : return \" %s . %s \" % ( self . module . refname , self . name ) else : return \" %s . %s \" % ( self . cls . refname , self . name ) class External ( Doc ): \"\"\" A representation of an external identifier. The textual representation is the same as an internal identifier, but without any context. (Usually this makes linking more difficult.) External identifiers are also used to represent something that is not exported but appears somewhere in the public interface (like the ancestor list of a class). \"\"\" __pdoc__ [ \"External.docstring\" ] = \"\"\" An empty string. External identifiers do not have docstrings. \"\"\" __pdoc__ [ \"External.module\" ] = \"\"\" Always `None`. External identifiers have no associated `pdoc.Module`. \"\"\" __pdoc__ [ \"External.name\" ] = \"\"\" Always equivalent to `pdoc.External.refname` since external identifiers are always expressed in their fully qualified form. \"\"\" def __init__ ( self , name ): \"\"\" Initializes an external identifier with `name`, where `name` should be a fully qualified name. \"\"\" super () . __init__ ( name , None , \"\" ) @property def source ( self ): return [] @property def refname ( self ): return self . name","title":"Module pdocs.doc"},{"location":"reference/pdocs/doc/#classes","text":"","title":"Classes"},{"location":"reference/pdocs/doc/#class","text":"class ( name , module , class_obj ) Representation of a class's documentation. View Source class Class ( Doc ) : \"\"\" Representation of a class ' s documentation. \"\"\" def __init__ ( self , name , module , class_obj ) : \"\"\" Same as ` pdocs . Doc . __init__ `, except ` class_obj ` must be a Python class object . The docstring is gathered automatically . \"\"\" super () . __init__ ( name , module , inspect . getdoc ( class_obj )) self . cls = class_obj \"\"\" The class Python object. \"\"\" self . doc = {} \"\"\" A mapping from identifier name to a `pdoc.Doc` objects. \"\"\" self . doc_init = {} \"\"\" A special version of ` pdoc . Class . doc ` that contains documentation for instance variables found in the ` __init__ ` method . \"\"\" public = self . __public_objs () try : # First try and find docstrings for class variables . # Then move on to finding docstrings for instance variables . # This must be optional , since not all modules have source # code available . cls_ast = ast . parse ( inspect . getsource ( self . cls )) . body [ 0 ] self . doc = _var_docstrings ( cls_ast , self . module , cls = self ) for n in cls_ast . body if \" __init__ \" in public else []: if isinstance ( n , ast . FunctionDef ) and n . name == \" __init__ \" : self . doc_init = _var_docstrings ( n , self . module , cls = self , init = True ) break except BaseException : pass # Convert the public Python objects to documentation objects . for name , obj in public . items () : # Skip any identifiers that already have doco . if name in self . doc and not self . doc [ name ]. is_empty () : continue if name in self . doc_init : # Let instance members override class members . continue if inspect . isroutine ( obj ) : self . doc [ name ] = Function ( name , self . module , obj , cls = self , method = _is_method ( self . cls , name ) ) elif isinstance ( obj , property ) : docstring = getattr ( obj , \" __doc__ \" , \"\" ) self . doc_init [ name ] = Variable ( name , self . module , docstring , cls = self ) elif not inspect . isbuiltin ( obj ) and not inspect . isroutine ( obj ) : if name in getattr ( self . cls , \" __slots__ \" , [] ) : self . doc_init [ name ] = Variable ( name , self . module , \"\" , cls = self ) else : self . doc [ name ] = Variable ( name , self . module , \"\" , cls = self ) @ property def source ( self ) : return _source ( self . cls ) @ property def refname ( self ) : return \" %s.%s \" % ( self . module . refname , self . cls . __name__ ) def class_variables ( self ) : \"\"\" Returns all documented class variables in the class , sorted alphabetically as a list of ` pdoc . Variable `. \"\"\" return _filter ( self . doc . values () , Variable ) def instance_variables ( self ) : \"\"\" Returns all instance variables in the class , sorted alphabetically as a list of ` pdoc . Variable `. Instance variables are attributes of ` self ` defined in a class ' s `__init__` method . \"\"\" return _filter ( self . doc_init . values () , Variable ) def methods ( self ) : \"\"\" Returns all documented methods as ` pdoc . Function ` objects in the class , sorted alphabetically . Unfortunately , this also includes class methods . \"\"\" return _filter ( self . doc . values () , Function , attributes_set = ( \" method \" , )) def functions ( self ) : \"\"\" Returns all documented static functions as ` pdoc . Function ` objects in the class , sorted alphabetically . \"\"\" return _filter ( self . doc . values () , Function , attributes_not_set = ( \" method \" , )) def params ( self ) : \"\"\" Returns back the parameters for the classes __init__ method \"\"\" params = Function . _params ( self . cls . __init__ ) return params [ 1 :] if params [ 0 ] == \" self \" else params def _fill_inheritance ( self ) : \"\"\" Traverses this class ' s ancestor list and attempts to fill in missing documentation from its ancestor ' s documentation. The first pass connects variables , methods and functions with their inherited couterparts . ( The templates will decide how to display docstrings . ) The second pass attempts to add instance variables to this class that were only explicitly declared in a parent class . This second pass is necessary since instance variables are only discoverable by traversing the abstract syntax tree . \"\"\" mro = [ c for c in self . module . mro ( self ) if c != self and isinstance ( c , Class ) ] def search ( d , fdoc ) : for c in mro : doc = fdoc ( c ) if d . name in doc and isinstance ( d , type ( doc [ d . name ] )) : return doc [ d . name ] return None for fdoc in ( lambda c : c . doc_init , lambda c : c . doc ) : for d in fdoc ( self ) . values () : dinherit = search ( d , fdoc ) if dinherit is not None : d . inherits = dinherit # Since instance variables aren ' t part of a class ' s members , # we need to manually deduce inheritance . Oh lawdy . for c in mro : for name in filter ( lambda n : n not in self . doc_init , c . doc_init ) : d = c . doc_init [ name ] self . doc_init [ name ] = Variable ( d . name , d . module , \"\" , cls = self ) self . doc_init [ name ]. inherits = d def mro ( self ) : \"\"\" Returns back the Method Resolution Order (MRO) for this class \"\"\" return [ self . module . find_class ( cls ) for cls in inspect . getmro ( self . cls ) if cls not in ( self . cls , object , self ) ] def subclasses ( self ) : \"\"\" Returns back all subclasses of this class \"\"\" return [ self . module . find_class ( cls ) for cls in type . __subclasses__ ( self . cls ) ] def __public_objs ( self ) : \"\"\" Returns a dictionary mapping a public identifier name to a Python object . This counts the ` __init__ ` method as being public . \"\"\" _pdoc = getattr ( self . module . module , \" __pdoc__ \" , {} ) def forced_out ( name ) : return _pdoc . get ( \" %s.%s \" % ( self . name , name ) , False ) is None def exported ( name ) : if _is_exported ( name ) and not forced_out ( name ) : return name idents = dict ( inspect . getmembers ( self . cls )) return dict ( [ ( n , o ) for n , o in idents . items () if exported ( n ) ] )","title":"Class"},{"location":"reference/pdocs/doc/#ancestors-in-mro","text":"pdocs.doc.Doc","title":"Ancestors (in MRO)"},{"location":"reference/pdocs/doc/#instance-variables","text":"refname source","title":"Instance variables"},{"location":"reference/pdocs/doc/#methods","text":"","title":"Methods"},{"location":"reference/pdocs/doc/#class_variables","text":"def ( self ) Returns all documented class variables in the class, sorted alphabetically as a list of pdoc.Variable . View Source def class_variables ( self ) : \"\"\" Returns all documented class variables in the class , sorted alphabetically as a list of ` pdoc . Variable `. \"\"\" return _filter ( self . doc . values () , Variable )","title":"class_variables"},{"location":"reference/pdocs/doc/#functions","text":"def ( self ) Returns all documented static functions as pdoc.Function objects in the class, sorted alphabetically. View Source def functions ( self ) : \"\"\" Returns all documented static functions as ` pdoc . Function ` objects in the class , sorted alphabetically . \"\"\" return _filter ( self . doc . values () , Function , attributes_not_set = ( \" method \" , ))","title":"functions"},{"location":"reference/pdocs/doc/#instance_variables","text":"def ( self ) Returns all instance variables in the class, sorted alphabetically as a list of pdoc.Variable . Instance variables are attributes of self defined in a class's __init__ method. View Source def instance_variables ( self ) : \"\"\" Returns all instance variables in the class , sorted alphabetically as a list of ` pdoc . Variable `. Instance variables are attributes of ` self ` defined in a class ' s `__init__` method . \"\"\" return _filter ( self . doc_init . values () , Variable )","title":"instance_variables"},{"location":"reference/pdocs/doc/#is_empty","text":"def ( self ) Returns true if the docstring for this object is empty. View Source def is_empty ( self ) : \"\"\" Returns true if the docstring for this object is empty . \"\"\" return len ( self . docstring . strip ()) == 0","title":"is_empty"},{"location":"reference/pdocs/doc/#methods_1","text":"def ( self ) Returns all documented methods as pdoc.Function objects in the class, sorted alphabetically. Unfortunately, this also includes class methods. View Source def methods ( self ) : \"\"\" Returns all documented methods as ` pdoc . Function ` objects in the class , sorted alphabetically . Unfortunately , this also includes class methods . \"\"\" return _filter ( self . doc . values () , Function , attributes_set = ( \" method \" , ))","title":"methods"},{"location":"reference/pdocs/doc/#mro","text":"def ( self ) Returns back the Method Resolution Order (MRO) for this class View Source def mro ( self ) : \"\"\" Returns back the Method Resolution Order (MRO) for this class \"\"\" return [ self . module . find_class ( cls ) for cls in inspect . getmro ( self . cls ) if cls not in ( self . cls , object , self ) ]","title":"mro"},{"location":"reference/pdocs/doc/#params","text":"def ( self ) Returns back the parameters for the classes init method View Source def params ( self ) : \"\"\" Returns back the parameters for the classes __init__ method \"\"\" params = Function . _params ( self . cls . __init__ ) return params [ 1 :] if params [ 0 ] == \" self \" else params","title":"params"},{"location":"reference/pdocs/doc/#subclasses","text":"def ( self ) Returns back all subclasses of this class View Source def subclasses ( self ) : \"\"\" Returns back all subclasses of this class \"\"\" return [ self . module . find_class ( cls ) for cls in type . __subclasses__ ( self . cls ) ]","title":"subclasses"},{"location":"reference/pdocs/doc/#doc","text":"class ( name , module , docstring ) A base class for all documentation objects. A documentation object corresponds to something in a Python module that has a docstring associated with it. Typically, this only includes modules, classes, functions and methods. However, pdoc adds support for extracting docstrings from the abstract syntax tree, which means that variables (module, class or instance) are supported too. A special type of documentation object pdoc.External is used to represent identifiers that are not part of the public interface of a module. (The name \"External\" is a bit of a misnomer, since it can also correspond to unexported members of the module, particularly in a class's ancestor list.) View Source class Doc ( object ) : \"\"\" A base class for all documentation objects . A documentation object corresponds to * something * in a Python module that has a docstring associated with it . Typically , this only includes modules , classes , functions and methods . However , ` pdoc ` adds support for extracting docstrings from the abstract syntax tree , which means that variables ( module , class or instance ) are supported too . A special type of documentation object ` pdoc . External ` is used to represent identifiers that are not part of the public interface of a module . ( The name \" External \" is a bit of a misnomer , since it can also correspond to unexported members of the module , particularly in a class ' s ancestor list.) \"\"\" def __init__ ( self , name , module , docstring ) : \"\"\" Initializes a documentation object , where ` name ` is the public identifier name , ` module ` is a ` pdoc . Module ` object , and ` docstring ` is a string containing the docstring for ` name `. \"\"\" self . module = module \"\"\" The module documentation object that this object was defined in . \"\"\" self . name = name \"\"\" The identifier name for this object . \"\"\" self . docstring = inspect . cleandoc ( docstring or \"\" ) \"\"\" The docstring for this object . It has already been cleaned by ` inspect . cleandoc `. \"\"\" @ property def source ( self ) : \"\"\" Returns the source code of the Python object ` obj ` as a list of lines . This tries to extract the source from the special ` __wrapped__ ` attribute if it exists . Otherwise , it falls back to ` inspect . getsourcelines `. If neither works , then the empty list is returned . \"\"\" raise NotImplementedError ( \" source() method should be implemented by sub casses \" ) @ property def refname ( self ) : \"\"\" Returns an appropriate reference name for this documentation object . Usually this is its fully qualified path . Every documentation object must provide this property . e . g ., The refname for this property is < code > pdoc . Doc . refname </ code > . \"\"\" raise NotImplementedError ( \" refname() method should be implemented by sub casses \" ) def __lt__ ( self , other ) : return self . name < other . name def is_empty ( self ) : \"\"\" Returns true if the docstring for this object is empty . \"\"\" return len ( self . docstring . strip ()) == 0","title":"Doc"},{"location":"reference/pdocs/doc/#descendants","text":"pdocs.doc.Module pdocs.doc.Class pdocs.doc.Function pdocs.doc.Variable pdocs.doc.External","title":"Descendants"},{"location":"reference/pdocs/doc/#instance-variables_1","text":"refname Returns an appropriate reference name for this documentation object. Usually this is its fully qualified path. Every documentation object must provide this property. e.g., The refname for this property is pdoc.Doc.refname . source Returns the source code of the Python object obj as a list of lines. This tries to extract the source from the special __wrapped__ attribute if it exists. Otherwise, it falls back to inspect.getsourcelines . If neither works, then the empty list is returned.","title":"Instance variables"},{"location":"reference/pdocs/doc/#methods_2","text":"","title":"Methods"},{"location":"reference/pdocs/doc/#is_empty_1","text":"def ( self ) Returns true if the docstring for this object is empty. View Source def is_empty ( self ) : \"\"\" Returns true if the docstring for this object is empty . \"\"\" return len ( self . docstring . strip ()) == 0","title":"is_empty"},{"location":"reference/pdocs/doc/#external","text":"class ( name ) A representation of an external identifier. The textual representation is the same as an internal identifier, but without any context. (Usually this makes linking more difficult.) External identifiers are also used to represent something that is not exported but appears somewhere in the public interface (like the ancestor list of a class). View Source class External ( Doc ) : \"\"\" A representation of an external identifier . The textual representation is the same as an internal identifier , but without any context . ( Usually this makes linking more difficult . ) External identifiers are also used to represent something that is not exported but appears somewhere in the public interface ( like the ancestor list of a class ) . \"\"\" __pdoc__ [ \" External.docstring \" ] = \"\"\" An empty string . External identifiers do not have docstrings . \"\"\" __pdoc__ [ \" External.module \" ] = \"\"\" Always ` None `. External identifiers have no associated ` pdoc . Module `. \"\"\" __pdoc__ [ \" External.name \" ] = \"\"\" Always equivalent to ` pdoc . External . refname ` since external identifiers are always expressed in their fully qualified form . \"\"\" def __init__ ( self , name ) : \"\"\" Initializes an external identifier with ` name `, where ` name ` should be a fully qualified name . \"\"\" super () . __init__ ( name , None , \"\" ) @ property def source ( self ) : return [] @ property def refname ( self ) : return self . name","title":"External"},{"location":"reference/pdocs/doc/#ancestors-in-mro_1","text":"pdocs.doc.Doc","title":"Ancestors (in MRO)"},{"location":"reference/pdocs/doc/#instance-variables_2","text":"refname source","title":"Instance variables"},{"location":"reference/pdocs/doc/#methods_3","text":"","title":"Methods"},{"location":"reference/pdocs/doc/#is_empty_2","text":"def ( self ) Returns true if the docstring for this object is empty. View Source def is_empty ( self ) : \"\"\" Returns true if the docstring for this object is empty . \"\"\" return len ( self . docstring . strip ()) == 0","title":"is_empty"},{"location":"reference/pdocs/doc/#function","text":"class ( name , module , func_obj , cls = None , method = False ) Representation of documentation for a Python function or method. View Source class Function ( Doc ) : \"\"\" Representation of documentation for a Python function or method . \"\"\" def __init__ ( self , name , module , func_obj , cls = None , method = False ) : \"\"\" Same as ` pdoc . Doc . __init__ `, except ` func_obj ` must be a Python function object . The docstring is gathered automatically . ` cls ` should be set when this is a method or a static function beloing to a class . ` cls ` should be a ` pdoc . Class ` object . ` method ` should be ` True ` when the function is a method . In all other cases , it should be ` False `. \"\"\" super () . __init__ ( name , module , inspect . getdoc ( func_obj )) self . func = func_obj \"\"\" The Python function object. \"\"\" self . cls = cls \"\"\" The ` pdoc . Class ` documentation object if this is a method . If not , this is None . \"\"\" self . method = method \"\"\" Whether this function is a method or not . In particular , static class methods have this set to False . \"\"\" @ property def source ( self ) : return _source ( self . func ) @ property def refname ( self ) : if self . cls is None : return \" %s.%s \" % ( self . module . refname , self . name ) else : return \" %s.%s \" % ( self . cls . refname , self . name ) def funcdef ( self ) : \"\"\" Generates the string of keywords used to define the function , for example ` def ` or ` async def `. \"\"\" keywords = [] if self . _is_async () : keywords . append ( \" async \" ) keywords . append ( \" def \" ) return \" \" . join ( keywords ) def _is_async ( self ) : \"\"\" Returns whether is function is asynchronous , either as a coroutine or an async generator . \"\"\" try : # Both of these are required because coroutines aren ' t classified as # async generators and vice versa . return inspect . iscoroutinefunction ( self . func ) or inspect . isasyncgenfunction ( self . func ) except AttributeError : return False def spec ( self ) : \"\"\" Returns a nicely formatted spec of the function ' s parameter list as a string . This includes argument lists , keyword arguments and default values . \"\"\" return \" , \" . join ( self . params ()) @ staticmethod def _signature ( function ) : try : return inspect . signature ( function ) except ( TypeError , ValueError ) : # We can ' t get a Python signature (likely C function) return False def return_annotation ( self ) : \"\"\" Returns back return type annotation if a valid one is found \"\"\" signature = self . _signature ( self . func ) if not signature or signature . return_annotation == inspect . _empty : return \"\" return inspect . formatannotation ( signature . return_annotation ) def params ( self ) : \"\"\" Returns a list where each element is a nicely formatted parameter of this function . This includes argument lists , keyword arguments and default values . \"\"\" return self . _params ( self . func ) @ classmethod def _params ( cls , function ) : \"\"\" Returns a list where each element is a nicely formatted parameter of this function . This includes argument lists , keyword arguments and default values . \"\"\" signature = cls . _signature ( function ) if not signature : return [ \" ... \" ] # The following is taken almost verbatim from the Python stdlib # https : // github . com / python / cpython / blob / 3 . 6 / Lib / inspect . py # L3017 # # This is done simply because it is hard to unstringify the result since commas could # be present beyond just between parameters . params = [] render_pos_only_separator = False render_kw_only_separator = True for param in signature . parameters . values () : kind = param . kind if kind == inspect . _POSITIONAL_ONLY : render_pos_only_separator = True elif render_pos_only_separator : params . append ( ' / ' ) render_pos_only_separator = False if kind == inspect . _VAR_POSITIONAL : render_kw_only_separator = False elif kind == inspect . _KEYWORD_ONLY and render_kw_only_separator : params . append ( ' * ' ) render_kw_only_separator = False params . append ( str ( param )) if render_pos_only_separator : params . append ( ' / ' ) return params def __lt__ ( self , other ) : # Push __init__ to the top . if \" __init__ \" in ( self . name , other . name ) : return self . name != other . name and self . name == \" __init__ \" else : return self . name < other . name","title":"Function"},{"location":"reference/pdocs/doc/#ancestors-in-mro_2","text":"pdocs.doc.Doc","title":"Ancestors (in MRO)"},{"location":"reference/pdocs/doc/#instance-variables_3","text":"refname source","title":"Instance variables"},{"location":"reference/pdocs/doc/#methods_4","text":"","title":"Methods"},{"location":"reference/pdocs/doc/#funcdef","text":"def ( self ) Generates the string of keywords used to define the function, for example def or async def . View Source def funcdef ( self ) : \"\"\" Generates the string of keywords used to define the function , for example ` def ` or ` async def `. \"\"\" keywords = [] if self . _is_async () : keywords . append ( \" async \" ) keywords . append ( \" def \" ) return \" \" . join ( keywords )","title":"funcdef"},{"location":"reference/pdocs/doc/#is_empty_3","text":"def ( self ) Returns true if the docstring for this object is empty. View Source def is_empty ( self ) : \"\"\" Returns true if the docstring for this object is empty . \"\"\" return len ( self . docstring . strip ()) == 0","title":"is_empty"},{"location":"reference/pdocs/doc/#params_1","text":"def ( self ) Returns a list where each element is a nicely formatted parameter of this function. This includes argument lists, keyword arguments and default values. View Source def params ( self ) : \"\"\" Returns a list where each element is a nicely formatted parameter of this function . This includes argument lists , keyword arguments and default values . \"\"\" return self . _params ( self . func )","title":"params"},{"location":"reference/pdocs/doc/#return_annotation","text":"def ( self ) Returns back return type annotation if a valid one is found View Source def return_annotation ( self ) : \"\"\" Returns back return type annotation if a valid one is found \"\"\" signature = self . _signature ( self . func ) if not signature or signature . return_annotation == inspect . _empty : return \"\" return inspect . formatannotation ( signature . return_annotation )","title":"return_annotation"},{"location":"reference/pdocs/doc/#spec","text":"def ( self ) Returns a nicely formatted spec of the function's parameter list as a string. This includes argument lists, keyword arguments and default values. View Source def spec ( self ) : \"\"\" Returns a nicely formatted spec of the function ' s parameter list as a string . This includes argument lists , keyword arguments and default values . \"\"\" return \" , \" . join ( self . params ())","title":"spec"},{"location":"reference/pdocs/doc/#module","text":"class ( name , module , parent ) Representation of a module's documentation. View Source class Module ( Doc ): \"\"\" Representation of a module's documentation. \"\"\" __pdoc__ [ \"Module.module\" ] = \"The Python module object.\" __pdoc__ [ \"Module.name\" ] = \"\"\" The name of this module with respect to the context in which it was imported. It is always an absolute import path. \"\"\" def __init__ ( self , name , module , parent ): \"\"\" Creates a `Module` documentation object given the actual module Python object. \"\"\" super () . __init__ ( name , module , inspect . getdoc ( module )) self . parent = parent self . doc = {} \"\"\"A mapping from identifier name to a documentation object.\"\"\" self . refdoc = {} \"\"\" The same as `pdoc.Module.doc`, but maps fully qualified identifier names to documentation objects. \"\"\" self . submodules = [] vardocs = {} try : tree = ast . parse ( inspect . getsource ( self . module )) vardocs = _var_docstrings ( tree , self , cls = None ) except BaseException : pass self . _declared_variables = vardocs . keys () public = self . __public_objs () for name , obj in public . items (): # Skip any identifiers that already have doco. if name in self . doc and not self . doc [ name ] . is_empty (): continue # Functions and some weird builtins?, plus methods, classes, # modules and module level variables. if inspect . isroutine ( obj ): self . doc [ name ] = Function ( name , self , obj ) elif inspect . isclass ( obj ): self . doc [ name ] = Class ( name , self , obj ) elif name in vardocs : self . doc [ name ] = vardocs [ name ] else : # Catch all for variables. self . doc [ name ] = Variable ( name , self , \"\" , cls = None ) # Now see if we can grab inheritance relationships between classes. for docobj in self . doc . values (): if isinstance ( docobj , Class ): docobj . _fill_inheritance () # Build the reference name dictionary. for _basename , docobj in self . doc . items (): self . refdoc [ docobj . refname ] = docobj if isinstance ( docobj , Class ): for v in docobj . class_variables (): self . refdoc [ v . refname ] = v for v in docobj . instance_variables (): self . refdoc [ v . refname ] = v for f in docobj . methods (): self . refdoc [ f . refname ] = f for f in docobj . functions (): self . refdoc [ f . refname ] = f # Finally look for more docstrings in the __pdoc__ override. for name , docstring in getattr ( self . module , \"__pdoc__\" , {}) . items (): refname = \" %s . %s \" % ( self . refname , name ) if docstring is None : self . doc . pop ( name , None ) self . refdoc . pop ( refname , None ) continue dobj = self . find_ident ( refname ) if isinstance ( dobj , External ): continue dobj . docstring = inspect . cleandoc ( docstring ) @property def source ( self ): return _source ( self . module ) @property def refname ( self ): return self . name @property def is_namespace ( self ): \"\"\"Returns `True` if this module represents a [namespace package](https://packaging.python.org/guides/packaging-namespace-packages/). \"\"\" return self . module . __spec__ . origin in ( None , \"namespace\" ) def mro ( self , cls ): \"\"\" Returns a method resolution list of ancestor documentation objects for `cls`, which must be a documentation object. The list will contain objects belonging to `pdoc.Class` or `pdoc.External`. Objects belonging to the former are exported classes either in this module or in one of its sub-modules. \"\"\" return [ self . find_class ( c ) for c in inspect . getmro ( cls . cls ) if c not in ( cls . cls , object )] def descendents ( self , cls ): \"\"\" Returns a descendent list of documentation objects for `cls`, which must be a documentation object. The list will contain objects belonging to `pdoc.Class` or `pdoc.External`. Objects belonging to the former are exported classes either in this module or in one of its sub-modules. \"\"\" if cls . cls == type or not hasattr ( cls . cls , \"__subclasses__\" ): # Is this right? return [] downs = cls . cls . __subclasses__ () return list ( map ( lambda c : self . find_class ( c ), downs )) def is_public ( self , name ): \"\"\" Returns `True` if and only if an identifier with name `name` is part of the public interface of this module. While the names of sub-modules are included, identifiers only exported by sub-modules are not checked. `name` should be a fully qualified name, e.g., <code>pdoc.Module.is_public</code>. \"\"\" return name in self . refdoc def find_class ( self , cls ): \"\"\" Given a Python `cls` object, try to find it in this module or in any of the exported identifiers of the submodules. \"\"\" for doc_cls in self . classes (): if cls is doc_cls . cls : return doc_cls for module in self . submodules : doc_cls = module . find_class ( cls ) if not isinstance ( doc_cls , External ): return doc_cls return External ( \" %s . %s \" % ( cls . __module__ , cls . __name__ )) def find_ident ( self , name , _seen = None ): \"\"\" Searches this module and **all** of its sub/super-modules for an identifier with name `name` in its list of exported identifiers according to `pdoc`. Note that unexported sub-modules are searched. A bare identifier (without `.` separators) will only be checked for in this module. The documentation object corresponding to the identifier is returned. If one cannot be found, then an instance of `External` is returned populated with the given identifier. \"\"\" _seen = _seen or set () if self in _seen : return None _seen . add ( self ) if name == self . refname : return self if name in self . refdoc : return self . refdoc [ name ] for module in self . submodules : o = module . find_ident ( name , _seen = _seen ) if not isinstance ( o , ( External , type ( None ))): return o # Traverse also up-level super-modules module = self . parent while module is not None : o = module . find_ident ( name , _seen = _seen ) if not isinstance ( o , ( External , type ( None ))): return o module = module . parent return External ( name ) def variables ( self ): \"\"\" Returns all documented module level variables in the module sorted alphabetically as a list of `pdoc.Variable`. \"\"\" return _filter ( self . doc . values (), Variable ) def classes ( self ): \"\"\" Returns all documented module level classes in the module sorted alphabetically as a list of `pdoc.Class`. \"\"\" return _filter ( self . doc . values (), Class ) def functions ( self ): \"\"\" Returns all documented module level functions in the module sorted alphabetically as a list of `pdoc.Function`. \"\"\" return _filter ( self . doc . values (), Function ) def __is_exported ( self , name , module ): \"\"\" Returns `True` if and only if `pdoc` considers `name` to be a public identifier for this module where `name` was defined in the Python module `module`. If this module has an `__all__` attribute, then `name` is considered to be exported if and only if it is a member of this module's `__all__` list. If `__all__` is not set, then whether `name` is exported or not is heuristically determined. Firstly, if `name` starts with an underscore, it will not be considered exported. Secondly, if `name` was defined in a module other than this one, it will not be considered exported. In all other cases, `name` will be considered exported. \"\"\" if hasattr ( self . module , \"__all__\" ): return name in self . module . __all__ if not _is_exported ( name ): return False if module is not None and self . module . __name__ != module . __name__ : return name in self . _declared_variables return True def __public_objs ( self ): \"\"\" Returns a dictionary mapping a public identifier name to a Python object. \"\"\" members = dict ( inspect . getmembers ( self . module )) return dict ( [ ( name , obj ) for name , obj in members . items () if self . __is_exported ( name , inspect . getmodule ( obj )) ] ) def allmodules ( self ): yield self for i in self . submodules : yield from i . allmodules () def toroot ( self ): n = self while n : yield n n = n . parent","title":"Module"},{"location":"reference/pdocs/doc/#ancestors-in-mro_3","text":"pdocs.doc.Doc","title":"Ancestors (in MRO)"},{"location":"reference/pdocs/doc/#instance-variables_4","text":"is_namespace Returns True if this module represents a namespace package . refname source","title":"Instance variables"},{"location":"reference/pdocs/doc/#methods_5","text":"","title":"Methods"},{"location":"reference/pdocs/doc/#allmodules","text":"def ( self ) View Source def allmodules ( self ) : yield self for i in self . submodules : yield from i . allmodules ()","title":"allmodules"},{"location":"reference/pdocs/doc/#classes_1","text":"def ( self ) Returns all documented module level classes in the module sorted alphabetically as a list of pdoc.Class . View Source def classes ( self ) : \"\"\" Returns all documented module level classes in the module sorted alphabetically as a list of ` pdoc . Class `. \"\"\" return _filter ( self . doc . values () , Class )","title":"classes"},{"location":"reference/pdocs/doc/#descendents","text":"def ( self , cls ) Returns a descendent list of documentation objects for cls , which must be a documentation object. The list will contain objects belonging to pdoc.Class or pdoc.External . Objects belonging to the former are exported classes either in this module or in one of its sub-modules. View Source def descendents ( self , cls ) : \"\"\" Returns a descendent list of documentation objects for ` cls `, which must be a documentation object . The list will contain objects belonging to ` pdoc . Class ` or ` pdoc . External `. Objects belonging to the former are exported classes either in this module or in one of its sub - modules . \"\"\" if cls . cls == type or not hasattr ( cls . cls , \" __subclasses__ \" ) : # Is this right ? return [] downs = cls . cls . __subclasses__ () return list ( map ( lambda c : self . find_class ( c ) , downs ))","title":"descendents"},{"location":"reference/pdocs/doc/#find_class","text":"def ( self , cls ) Given a Python cls object, try to find it in this module or in any of the exported identifiers of the submodules. View Source def find_class ( self , cls ) : \"\"\" Given a Python ` cls ` object , try to find it in this module or in any of the exported identifiers of the submodules . \"\"\" for doc_cls in self . classes () : if cls is doc_cls . cls : return doc_cls for module in self . submodules : doc_cls = module . find_class ( cls ) if not isinstance ( doc_cls , External ) : return doc_cls return External ( \" %s.%s \" % ( cls . __module__ , cls . __name__ ))","title":"find_class"},{"location":"reference/pdocs/doc/#find_ident","text":"def ( self , name , _seen = None ) Searches this module and all of its sub/super-modules for an identifier with name name in its list of exported identifiers according to pdoc . Note that unexported sub-modules are searched. A bare identifier (without . separators) will only be checked for in this module. The documentation object corresponding to the identifier is returned. If one cannot be found, then an instance of External is returned populated with the given identifier. View Source def find_ident ( self , name , _seen = None ) : \"\"\" Searches this module and ** all ** of its sub / super - modules for an identifier with name ` name ` in its list of exported identifiers according to ` pdoc `. Note that unexported sub - modules are searched . A bare identifier ( without `.` separators ) will only be checked for in this module . The documentation object corresponding to the identifier is returned . If one cannot be found , then an instance of ` External ` is returned populated with the given identifier . \"\"\" _seen = _seen or set () if self in _seen : return None _seen . add ( self ) if name == self . refname : return self if name in self . refdoc : return self . refdoc [ name ] for module in self . submodules : o = module . find_ident ( name , _seen = _seen ) if not isinstance ( o , ( External , type ( None ))) : return o # Traverse also up - level super - modules module = self . parent while module is not None : o = module . find_ident ( name , _seen = _seen ) if not isinstance ( o , ( External , type ( None ))) : return o module = module . parent return External ( name )","title":"find_ident"},{"location":"reference/pdocs/doc/#functions_1","text":"def ( self ) Returns all documented module level functions in the module sorted alphabetically as a list of pdoc.Function . View Source def functions ( self ) : \"\"\" Returns all documented module level functions in the module sorted alphabetically as a list of ` pdoc . Function `. \"\"\" return _filter ( self . doc . values () , Function )","title":"functions"},{"location":"reference/pdocs/doc/#is_empty_4","text":"def ( self ) Returns true if the docstring for this object is empty. View Source def is_empty ( self ) : \"\"\" Returns true if the docstring for this object is empty . \"\"\" return len ( self . docstring . strip ()) == 0","title":"is_empty"},{"location":"reference/pdocs/doc/#is_public","text":"def ( self , name ) Returns True if and only if an identifier with name name is part of the public interface of this module. While the names of sub-modules are included, identifiers only exported by sub-modules are not checked. name should be a fully qualified name, e.g., pdoc.Module.is_public . View Source def is_public ( self , name ) : \"\"\" Returns ` True ` if and only if an identifier with name ` name ` is part of the public interface of this module . While the names of sub - modules are included , identifiers only exported by sub - modules are not checked . ` name ` should be a fully qualified name , e . g ., < code > pdoc . Module . is_public </ code > . \"\"\" return name in self . refdoc","title":"is_public"},{"location":"reference/pdocs/doc/#mro_1","text":"def ( self , cls ) Returns a method resolution list of ancestor documentation objects for cls , which must be a documentation object. The list will contain objects belonging to pdoc.Class or pdoc.External . Objects belonging to the former are exported classes either in this module or in one of its sub-modules. View Source def mro ( self , cls ) : \"\"\" Returns a method resolution list of ancestor documentation objects for ` cls `, which must be a documentation object . The list will contain objects belonging to ` pdoc . Class ` or ` pdoc . External `. Objects belonging to the former are exported classes either in this module or in one of its sub - modules . \"\"\" return [ self . find_class ( c ) for c in inspect . getmro ( cls . cls ) if c not in ( cls . cls , object ) ]","title":"mro"},{"location":"reference/pdocs/doc/#toroot","text":"def ( self ) View Source def toroot ( self ) : n = self while n : yield n n = n . parent","title":"toroot"},{"location":"reference/pdocs/doc/#variables","text":"def ( self ) Returns all documented module level variables in the module sorted alphabetically as a list of pdoc.Variable . View Source def variables ( self ) : \"\"\" Returns all documented module level variables in the module sorted alphabetically as a list of ` pdoc . Variable `. \"\"\" return _filter ( self . doc . values () , Variable )","title":"variables"},{"location":"reference/pdocs/doc/#variable","text":"class ( name , module , docstring , cls = None ) Representation of a variable's documentation. This includes module, class and instance variables. View Source class Variable ( Doc ) : \"\"\" Representation of a variable ' s documentation. This includes module , class and instance variables . \"\"\" def __init__ ( self , name , module , docstring , cls = None ) : \"\"\" Same as ` pdoc . Doc . __init__ `, except ` cls ` should be provided as a ` pdoc . Class ` object when this is a class or instance variable . \"\"\" super () . __init__ ( name , module , docstring ) self . cls = cls \"\"\" The ` podc . Class ` object if this is a class or instance variable . If not , this is None . \"\"\" @ property def source ( self ) : return [] @ property def refname ( self ) : if self . cls is None : return \" %s.%s \" % ( self . module . refname , self . name ) else : return \" %s.%s \" % ( self . cls . refname , self . name )","title":"Variable"},{"location":"reference/pdocs/doc/#ancestors-in-mro_4","text":"pdocs.doc.Doc","title":"Ancestors (in MRO)"},{"location":"reference/pdocs/doc/#instance-variables_5","text":"refname source","title":"Instance variables"},{"location":"reference/pdocs/doc/#methods_6","text":"","title":"Methods"},{"location":"reference/pdocs/doc/#is_empty_5","text":"def ( self ) Returns true if the docstring for this object is empty. View Source def is_empty ( self ) : \"\"\" Returns true if the docstring for this object is empty . \"\"\" return len ( self . docstring . strip ()) == 0","title":"is_empty"},{"location":"reference/pdocs/extract/","text":"Module pdocs.extract View Source import importlib import os import pkgutil import typing import pdocs . doc class ExtractError ( Exception ) : pass def split_module_spec ( spec : str ) -> typing . Tuple [ str , str ] : \"\"\" Splits a module specification into a base path (which may be empty), and a module name. Raises ExtactError if the spec is invalid. \"\"\" if not spec : raise ExtractError ( \"Empty module spec.\" ) if ( os . sep in spec ) or ( os . altsep and os . altsep in spec ) : dirname , fname = os . path . split ( spec ) if fname . endswith ( \".py\" ) : mname , _ = os . path . splitext ( fname ) return dirname , mname else : if \".\" in fname : raise ExtractError ( \"Invalid module name {fname}. Mixing path and module specifications \" \"is not supported.\" . format ( fname = fname ) ) return dirname , fname else : return \"\" , spec def load_module ( basedir : str , module : str ) -> typing . Tuple [ typing . Any , bool ] : \"\"\" Returns a module object, and whether the module is a package or not. \"\"\" ispackage = False if basedir : mods = module . split ( \".\" ) dirname = os . path . join ( basedir , * mods [:- 1 ]) modname = mods [ - 1 ] pkgloc = os . path . join ( dirname , modname , \"__init__.py\" ) fileloc = os . path . join ( dirname , modname + \".py\" ) if os . path . exists ( pkgloc ) : location , ispackage = pkgloc , True elif os . path . exists ( fileloc ) : location , ispackage = fileloc , False else : raise ExtractError ( \"Module {module} not found in {basedir}\" . format ( module = module , basedir = basedir ) ) ispec = importlib . util . spec_from_file_location ( modname , location ) mobj = importlib . util . module_from_spec ( ispec ) try : # This can literally raise anything ispec . loader . exec_module ( mobj ) # type : ignore except Exception as e : raise ExtractError ( \"Error importing {location}: {e}\" . format ( location = location , e = e )) return mobj , ispackage else : try : # This can literally raise anything m = importlib . import_module ( module ) except ImportError : raise ExtractError ( \"Module not found: {module}\" . format ( module = module )) except Exception as e : raise ExtractError ( \"Error importing {module}: {e}\" . format ( module = module , e = e )) # This is the only case where we actually have to test whether we ' re a package if getattr ( m , \"__package__\" , False ) and getattr ( m , \"__path__\" , False ) : ispackage = True return m , ispackage def submodules ( dname : str , mname : str ) -> typing . Sequence [ str ] : \"\"\" Returns a list of fully qualified submodules within a package, given a base directory and a fully qualified module name. \"\"\" loc = os . path . join ( dname , * mname . split ( \".\" )) ret = [] for mi in pkgutil . iter_modules ([ loc ], prefix = mname + \".\" ) : if isinstance ( mi , tuple ) : # Python 3.5 compat ret . append ( mi [ 1 ]) else : ret . append ( mi . name ) ret . sort () return ret def _ extract_module ( dname : str , mname : str , parent = None ) -> typing . Any : m , pkg = load_module ( dname , mname ) mod = pdocs . doc . Module ( mname , m , parent ) if pkg : for submodule_full_name in submodules ( dname , mname ) : if submodule_full_name . split ( \".\" )[ - 1 ]. startswith ( \"_\" ) : continue mod . submodules . append ( _ extract_module ( dname , submodule_full_name , parent =mod )) return mod def extract_module ( spec : str ) : \"\"\" Extracts and returns a module object. The spec argument can have the following forms: Simple module: \" foo . bar \" Module path: \" . / path / to / module \" File path: \" . / path / to / file . py \" This function always invalidates caches to enable hot load and reload. May raise ExtactError. \"\"\" importlib . invalidate_caches () dname , mname = split_module_spec ( spec ) return _ extract_module ( dname , mname ) Functions extract_module def ( spec : str ) Extracts and returns a module object. The spec argument can have the following forms: Simple module: \"foo.bar\" Module path: \"./path/to/module\" File path: \"./path/to/file.py\" This function always invalidates caches to enable hot load and reload. May raise ExtactError. View Source def extract_module ( spec : str ) : \"\"\" Extracts and returns a module object . The spec argument can have the following forms : Simple module : \" foo.bar \" Module path : \" ./path/to/module \" File path : \" ./path/to/file.py \" This function always invalidates caches to enable hot load and reload . May raise ExtactError . \"\"\" importlib . invalidate_caches () dname , mname = split_module_spec ( spec ) return _extract_module ( dname , mname ) load_module def ( basedir : str , module : str ) -> Tuple [ Any , bool ] Returns a module object, and whether the module is a package or not. View Source def load_module ( basedir : str , module : str ) -> typing . Tuple [ typing . Any , bool ] : \"\"\" Returns a module object, and whether the module is a package or not. \"\"\" ispackage = False if basedir : mods = module . split ( \".\" ) dirname = os . path . join ( basedir , * mods [:- 1 ]) modname = mods [ - 1 ] pkgloc = os . path . join ( dirname , modname , \"__init__.py\" ) fileloc = os . path . join ( dirname , modname + \".py\" ) if os . path . exists ( pkgloc ) : location , ispackage = pkgloc , True elif os . path . exists ( fileloc ) : location , ispackage = fileloc , False else : raise ExtractError ( \"Module {module} not found in {basedir}\" . format ( module = module , basedir = basedir ) ) ispec = importlib . util . spec_from_file_location ( modname , location ) mobj = importlib . util . module_from_spec ( ispec ) try : # This can literally raise anything ispec . loader . exec_module ( mobj ) # type : ignore except Exception as e : raise ExtractError ( \"Error importing {location}: {e}\" . format ( location = location , e = e )) return mobj , ispackage else : try : # This can literally raise anything m = importlib . import_module ( module ) except ImportError : raise ExtractError ( \"Module not found: {module}\" . format ( module = module )) except Exception as e : raise ExtractError ( \"Error importing {module}: {e}\" . format ( module = module , e = e )) # This is the only case where we actually have to test whether we ' re a package if getattr ( m , \"__package__\" , False ) and getattr ( m , \"__path__\" , False ) : ispackage = True return m , ispackage split_module_spec def ( spec : str ) -> Tuple [ str , str ] Splits a module specification into a base path (which may be empty), and a module name. Raises ExtactError if the spec is invalid. View Source def split_module_spec ( spec : str ) -> typing . Tuple [ str , str ]: \"\"\" Splits a module specification into a base path ( which may be empty ) , and a module name . Raises ExtactError if the spec is invalid . \"\"\" if not spec : raise ExtractError ( \" Empty module spec. \" ) if ( os . sep in spec ) or ( os . altsep and os . altsep in spec ) : dirname , fname = os . path . split ( spec ) if fname . endswith ( \" .py \" ) : mname , _ = os . path . splitext ( fname ) return dirname , mname else : if \" . \" in fname : raise ExtractError ( \" Invalid module name {fname}. Mixing path and module specifications \" \" is not supported. \" . format ( fname = fname ) ) return dirname , fname else : return \"\" , spec submodules def ( dname : str , mname : str ) -> Sequence [ str ] Returns a list of fully qualified submodules within a package, given a base directory and a fully qualified module name. View Source def submodules ( dname : str , mname : str ) -> typing . Sequence [ str ]: \"\"\" Returns a list of fully qualified submodules within a package , given a base directory and a fully qualified module name . \"\"\" loc = os . path . join ( dname , * mname . split ( \" . \" )) ret = [] for mi in pkgutil . iter_modules ( [ loc ], prefix = mname + \" . \" ) : if isinstance ( mi , tuple ) : # Python 3 . 5 compat ret . append ( mi [ 1 ] ) else : ret . append ( mi . name ) ret . sort () return ret Classes ExtractError class ( / , * args , ** kwargs ) Common base class for all non-exit exceptions. View Source class ExtractError ( Exception ): pass Ancestors (in MRO) builtins.Exception builtins.BaseException Class variables args Methods with_traceback def ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"Extract"},{"location":"reference/pdocs/extract/#module-pdocsextract","text":"View Source import importlib import os import pkgutil import typing import pdocs . doc class ExtractError ( Exception ) : pass def split_module_spec ( spec : str ) -> typing . Tuple [ str , str ] : \"\"\" Splits a module specification into a base path (which may be empty), and a module name. Raises ExtactError if the spec is invalid. \"\"\" if not spec : raise ExtractError ( \"Empty module spec.\" ) if ( os . sep in spec ) or ( os . altsep and os . altsep in spec ) : dirname , fname = os . path . split ( spec ) if fname . endswith ( \".py\" ) : mname , _ = os . path . splitext ( fname ) return dirname , mname else : if \".\" in fname : raise ExtractError ( \"Invalid module name {fname}. Mixing path and module specifications \" \"is not supported.\" . format ( fname = fname ) ) return dirname , fname else : return \"\" , spec def load_module ( basedir : str , module : str ) -> typing . Tuple [ typing . Any , bool ] : \"\"\" Returns a module object, and whether the module is a package or not. \"\"\" ispackage = False if basedir : mods = module . split ( \".\" ) dirname = os . path . join ( basedir , * mods [:- 1 ]) modname = mods [ - 1 ] pkgloc = os . path . join ( dirname , modname , \"__init__.py\" ) fileloc = os . path . join ( dirname , modname + \".py\" ) if os . path . exists ( pkgloc ) : location , ispackage = pkgloc , True elif os . path . exists ( fileloc ) : location , ispackage = fileloc , False else : raise ExtractError ( \"Module {module} not found in {basedir}\" . format ( module = module , basedir = basedir ) ) ispec = importlib . util . spec_from_file_location ( modname , location ) mobj = importlib . util . module_from_spec ( ispec ) try : # This can literally raise anything ispec . loader . exec_module ( mobj ) # type : ignore except Exception as e : raise ExtractError ( \"Error importing {location}: {e}\" . format ( location = location , e = e )) return mobj , ispackage else : try : # This can literally raise anything m = importlib . import_module ( module ) except ImportError : raise ExtractError ( \"Module not found: {module}\" . format ( module = module )) except Exception as e : raise ExtractError ( \"Error importing {module}: {e}\" . format ( module = module , e = e )) # This is the only case where we actually have to test whether we ' re a package if getattr ( m , \"__package__\" , False ) and getattr ( m , \"__path__\" , False ) : ispackage = True return m , ispackage def submodules ( dname : str , mname : str ) -> typing . Sequence [ str ] : \"\"\" Returns a list of fully qualified submodules within a package, given a base directory and a fully qualified module name. \"\"\" loc = os . path . join ( dname , * mname . split ( \".\" )) ret = [] for mi in pkgutil . iter_modules ([ loc ], prefix = mname + \".\" ) : if isinstance ( mi , tuple ) : # Python 3.5 compat ret . append ( mi [ 1 ]) else : ret . append ( mi . name ) ret . sort () return ret def _ extract_module ( dname : str , mname : str , parent = None ) -> typing . Any : m , pkg = load_module ( dname , mname ) mod = pdocs . doc . Module ( mname , m , parent ) if pkg : for submodule_full_name in submodules ( dname , mname ) : if submodule_full_name . split ( \".\" )[ - 1 ]. startswith ( \"_\" ) : continue mod . submodules . append ( _ extract_module ( dname , submodule_full_name , parent =mod )) return mod def extract_module ( spec : str ) : \"\"\" Extracts and returns a module object. The spec argument can have the following forms: Simple module: \" foo . bar \" Module path: \" . / path / to / module \" File path: \" . / path / to / file . py \" This function always invalidates caches to enable hot load and reload. May raise ExtactError. \"\"\" importlib . invalidate_caches () dname , mname = split_module_spec ( spec ) return _ extract_module ( dname , mname )","title":"Module pdocs.extract"},{"location":"reference/pdocs/extract/#functions","text":"","title":"Functions"},{"location":"reference/pdocs/extract/#extract_module","text":"def ( spec : str ) Extracts and returns a module object. The spec argument can have the following forms: Simple module: \"foo.bar\" Module path: \"./path/to/module\" File path: \"./path/to/file.py\" This function always invalidates caches to enable hot load and reload. May raise ExtactError. View Source def extract_module ( spec : str ) : \"\"\" Extracts and returns a module object . The spec argument can have the following forms : Simple module : \" foo.bar \" Module path : \" ./path/to/module \" File path : \" ./path/to/file.py \" This function always invalidates caches to enable hot load and reload . May raise ExtactError . \"\"\" importlib . invalidate_caches () dname , mname = split_module_spec ( spec ) return _extract_module ( dname , mname )","title":"extract_module"},{"location":"reference/pdocs/extract/#load_module","text":"def ( basedir : str , module : str ) -> Tuple [ Any , bool ] Returns a module object, and whether the module is a package or not. View Source def load_module ( basedir : str , module : str ) -> typing . Tuple [ typing . Any , bool ] : \"\"\" Returns a module object, and whether the module is a package or not. \"\"\" ispackage = False if basedir : mods = module . split ( \".\" ) dirname = os . path . join ( basedir , * mods [:- 1 ]) modname = mods [ - 1 ] pkgloc = os . path . join ( dirname , modname , \"__init__.py\" ) fileloc = os . path . join ( dirname , modname + \".py\" ) if os . path . exists ( pkgloc ) : location , ispackage = pkgloc , True elif os . path . exists ( fileloc ) : location , ispackage = fileloc , False else : raise ExtractError ( \"Module {module} not found in {basedir}\" . format ( module = module , basedir = basedir ) ) ispec = importlib . util . spec_from_file_location ( modname , location ) mobj = importlib . util . module_from_spec ( ispec ) try : # This can literally raise anything ispec . loader . exec_module ( mobj ) # type : ignore except Exception as e : raise ExtractError ( \"Error importing {location}: {e}\" . format ( location = location , e = e )) return mobj , ispackage else : try : # This can literally raise anything m = importlib . import_module ( module ) except ImportError : raise ExtractError ( \"Module not found: {module}\" . format ( module = module )) except Exception as e : raise ExtractError ( \"Error importing {module}: {e}\" . format ( module = module , e = e )) # This is the only case where we actually have to test whether we ' re a package if getattr ( m , \"__package__\" , False ) and getattr ( m , \"__path__\" , False ) : ispackage = True return m , ispackage","title":"load_module"},{"location":"reference/pdocs/extract/#split_module_spec","text":"def ( spec : str ) -> Tuple [ str , str ] Splits a module specification into a base path (which may be empty), and a module name. Raises ExtactError if the spec is invalid. View Source def split_module_spec ( spec : str ) -> typing . Tuple [ str , str ]: \"\"\" Splits a module specification into a base path ( which may be empty ) , and a module name . Raises ExtactError if the spec is invalid . \"\"\" if not spec : raise ExtractError ( \" Empty module spec. \" ) if ( os . sep in spec ) or ( os . altsep and os . altsep in spec ) : dirname , fname = os . path . split ( spec ) if fname . endswith ( \" .py \" ) : mname , _ = os . path . splitext ( fname ) return dirname , mname else : if \" . \" in fname : raise ExtractError ( \" Invalid module name {fname}. Mixing path and module specifications \" \" is not supported. \" . format ( fname = fname ) ) return dirname , fname else : return \"\" , spec","title":"split_module_spec"},{"location":"reference/pdocs/extract/#submodules","text":"def ( dname : str , mname : str ) -> Sequence [ str ] Returns a list of fully qualified submodules within a package, given a base directory and a fully qualified module name. View Source def submodules ( dname : str , mname : str ) -> typing . Sequence [ str ]: \"\"\" Returns a list of fully qualified submodules within a package , given a base directory and a fully qualified module name . \"\"\" loc = os . path . join ( dname , * mname . split ( \" . \" )) ret = [] for mi in pkgutil . iter_modules ( [ loc ], prefix = mname + \" . \" ) : if isinstance ( mi , tuple ) : # Python 3 . 5 compat ret . append ( mi [ 1 ] ) else : ret . append ( mi . name ) ret . sort () return ret","title":"submodules"},{"location":"reference/pdocs/extract/#classes","text":"","title":"Classes"},{"location":"reference/pdocs/extract/#extracterror","text":"class ( / , * args , ** kwargs ) Common base class for all non-exit exceptions. View Source class ExtractError ( Exception ): pass","title":"ExtractError"},{"location":"reference/pdocs/extract/#ancestors-in-mro","text":"builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/pdocs/extract/#class-variables","text":"args","title":"Class variables"},{"location":"reference/pdocs/extract/#methods","text":"","title":"Methods"},{"location":"reference/pdocs/extract/#with_traceback","text":"def ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/pdocs/html_helpers/","text":"Module pdocs.html_helpers View Source import os import re import sys import markdown import pygments import pygments . formatters import pygments . lexers import pdocs . doc import pdocs . render from pdocs import defaults # From language reference , but adds '.' to allow fully qualified names . pyident = re . compile ( r \"^[a-zA-Z_][a-zA-Z0-9_.]+$\" ) indent = re . compile ( r \"^\\s*\" ) _ markdown = markdown . Markdown ( output_format= \"html5\" , extensions = defaults . MARKDOWN_EXTENSIONS , extension_configs = defaults . MARKDOWN_EXTENSION_CONFIGS , ) def _ markdown_render ( text ) : return _ markdown . reset (). convert ( text ) def decode ( s ) : if sys . version_info [ 0 ] < 3 and isinstance ( s , str ) : return s . decode ( \"utf-8\" , \"ignore\" ) return s def ident ( s ) : return '<span class=\"ident\">%s</span>' % s def sourceid ( dobj ) : return \"source-%s\" % dobj.refname def clean_source_lines ( lines ) : \"\"\" Cleans the source code so that pygments can render it well. Returns one string with all of the source code. \"\"\" base_indent = len ( indent . match ( lines [ 0 ]). group ( 0 )) base_indent = 0 for line in lines : if len ( line . strip ()) > 0 : base_indent = len ( indent . match ( lines [ 0 ]). group ( 0 )) break lines = [ line [ base_indent: ] for line in lines ] if sys . version_info [ 0 ] < 3 : pylex = pygments . lexers . PythonLexer () else : pylex = pygments . lexers . Python3Lexer () htmlform = pygments . formatters . HtmlFormatter ( cssclass= \"codehilite\" ) return pygments . highlight ( \"\" . join ( lines ), pylex , htmlform ) def linkify ( parent , match , link_prefix ) : matched = match . group ( 0 ) ident = matched [ 1 :- 1 ] name , url = lookup ( parent , ident , link_prefix ) if name is None : return matched return \"[`%s`](%s)\" % (name, url) def mark ( text , module_list = None , linky = True ) : if linky : text , _ = re . subn ( \"\\b\\n\\b\" , \" \" , text ) return _ markdown_render ( text . strip ()) def glimpse ( s , length = 100 ) : if len ( s ) < length : return s return s [ 0 :length ] + \"...\" def module_url ( parent , m , link_prefix ) : \"\"\" Returns a URL for `m`, which must be an instance of `Module`. Also, `m` must be a submodule of the module being documented. Namely, '.' import separators are replaced with '/' URL separators. Also, packages are translated as directories containing `index.html` corresponding to the `__init__` module, while modules are translated as regular HTML files with an `.m.html` suffix. (Given default values of `pdoc.html_module_suffix` and `pdoc.html_package_name`.) \"\"\" if parent . name == m . name : return \"\" base = m . name . replace ( \".\" , \"/\" ) if len ( link_prefix ) == 0 : base = os . path . relpath ( base , parent . name . replace ( \".\" , \"/\" )) url = base [ len ( \"../\" ) : ] if base . startswith ( \"../\" ) else \"\" if base == \"..\" else base if m . submodules : index = pdocs . render . html_package_name url = url + \"/\" + index if url else index else : url += pdocs . render . html_module_suffix return link_prefix + url def external_url ( refname ) : \"\"\" Attempts to guess an absolute URL for the external identifier given. Note that this just returns the refname with an \" . ext \" suffix. It will be up to whatever is interpreting the URLs to map it to an appropriate documentation page. \"\"\" return \"/%s.ext\" % refname def is_external_linkable ( name ) : return pyident . match ( name ) and \".\" in name def lookup ( module , refname , link_prefix ) : \"\"\" Given a fully qualified identifier name, return its refname with respect to the current module and a value for a `href` attribute. If `refname` is not in the public interface of this module or its submodules, then `None` is returned for both return values. (Unless this module has enabled external linking.) In particular, this takes into account sub-modules and external identifiers. If `refname` is in the public API of the current module, then a local anchor link is given. If `refname` is in the public API of a sub-module, then a link to a different page with the appropriate anchor is given. Otherwise, `refname` is considered external and no link is used. \"\"\" d = module . find_ident ( refname ) if isinstance ( d , pdocs . doc . External ) : if is_external_linkable ( refname ) : return d . refname , external_url ( d . refname ) else : return None , None if isinstance ( d , pdocs . doc . Module ) : return d . refname , module_url ( module , d , link_prefix ) if module . is_public ( d . refname ) : return d . name , \"#%s\" % d.refname return d . refname , \"%s#%s\" % (module_url(module, d.module, link_prefix), d.refname) def link ( parent , refname , link_prefix ) : \"\"\" A convenience wrapper around `href` to produce the full `a` tag if `refname` is found. Otherwise, plain text of `refname` is returned. \"\"\" name , url = lookup ( parent , refname , link_prefix ) if name is None : return refname return '<a href=\"%s\">%s</a>' % (url, name) Variables indent pyident Functions clean_source_lines def ( lines ) Cleans the source code so that pygments can render it well. Returns one string with all of the source code. View Source def clean_source_lines ( lines ) : \"\"\" Cleans the source code so that pygments can render it well . Returns one string with all of the source code . \"\"\" base_indent = len ( indent . match ( lines [ 0 ] ) . group ( 0 )) base_indent = 0 for line in lines : if len ( line . strip ()) > 0 : base_indent = len ( indent . match ( lines [ 0 ] ) . group ( 0 )) break lines = [ line [ base_indent :] for line in lines ] if sys . version_info [ 0 ] < 3 : pylex = pygments . lexers . PythonLexer () else : pylex = pygments . lexers . Python3Lexer () htmlform = pygments . formatters . HtmlFormatter ( cssclass = \" codehilite \" ) return pygments . highlight ( \"\" . join ( lines ) , pylex , htmlform ) decode def ( s ) View Source def decode ( s ) : if sys . version_info [ 0 ] < 3 and isinstance ( s , str ) : return s . decode ( \" utf-8 \" , \" ignore \" ) return s external_url def ( refname ) Attempts to guess an absolute URL for the external identifier given. Note that this just returns the refname with an \".ext\" suffix. It will be up to whatever is interpreting the URLs to map it to an appropriate documentation page. View Source def external_url ( refname ) : \"\"\" Attempts to guess an absolute URL for the external identifier given . Note that this just returns the refname with an \" .ext \" suffix . It will be up to whatever is interpreting the URLs to map it to an appropriate documentation page . \"\"\" return \" /%s.ext \" % refname glimpse def ( s , length = 100 ) View Source def glimpse ( s , length = 100 ) : if len ( s ) < length : return s return s [ 0 : length ] + \" ... \" ident def ( s ) View Source def ident ( s ) : return ' <span class=\"ident\">%s</span> ' % s is_external_linkable def ( name ) View Source def is_external_linkable ( name ) : return pyident . match ( name ) and \" . \" in name link def ( parent , refname , link_prefix ) A convenience wrapper around href to produce the full a tag if refname is found. Otherwise, plain text of refname is returned. View Source def link ( parent , refname , link_prefix ) : \"\"\" A convenience wrapper around ` href ` to produce the full ` a ` tag if ` refname ` is found . Otherwise , plain text of ` refname ` is returned . \"\"\" name , url = lookup ( parent , refname , link_prefix ) if name is None : return refname return ' <a href=\"%s\">%s</a> ' % ( url , name ) linkify def ( parent , match , link_prefix ) View Source def linkify ( parent , match , link_prefix ) : matched = match . group ( 0 ) ident = matched [ 1 :- 1 ] name , url = lookup ( parent , ident , link_prefix ) if name is None : return matched return \"[`%s`](%s)\" % (name, url) lookup def ( module , refname , link_prefix ) Given a fully qualified identifier name, return its refname with respect to the current module and a value for a href attribute. If refname is not in the public interface of this module or its submodules, then None is returned for both return values. (Unless this module has enabled external linking.) In particular, this takes into account sub-modules and external identifiers. If refname is in the public API of the current module, then a local anchor link is given. If refname is in the public API of a sub-module, then a link to a different page with the appropriate anchor is given. Otherwise, refname is considered external and no link is used. View Source def lookup ( module , refname , link_prefix ) : \"\"\" Given a fully qualified identifier name , return its refname with respect to the current module and a value for a ` href ` attribute . If ` refname ` is not in the public interface of this module or its submodules , then ` None ` is returned for both return values . ( Unless this module has enabled external linking . ) In particular , this takes into account sub - modules and external identifiers . If ` refname ` is in the public API of the current module , then a local anchor link is given . If ` refname ` is in the public API of a sub - module , then a link to a different page with the appropriate anchor is given . Otherwise , ` refname ` is considered external and no link is used . \"\"\" d = module . find_ident ( refname ) if isinstance ( d , pdocs . doc . External ) : if is_external_linkable ( refname ) : return d . refname , external_url ( d . refname ) else : return None , None if isinstance ( d , pdocs . doc . Module ) : return d . refname , module_url ( module , d , link_prefix ) if module . is_public ( d . refname ) : return d . name , \" #%s \" % d . refname return d . refname , \" %s#%s \" % ( module_url ( module , d . module , link_prefix ) , d . refname ) mark def ( text , module_list = None , linky = True ) View Source def mark ( text , module_list = None , linky = True ) : if linky : text , _ = re . subn ( \" \\b \\n \\b \" , \" \" , text ) return _markdown_render ( text . strip ()) module_url def ( parent , m , link_prefix ) Returns a URL for m , which must be an instance of Module . Also, m must be a submodule of the module being documented. Namely, '.' import separators are replaced with '/' URL separators. Also, packages are translated as directories containing index.html corresponding to the __init__ module, while modules are translated as regular HTML files with an .m.html suffix. (Given default values of pdoc.html_module_suffix and pdoc.html_package_name .) View Source def module_url ( parent , m , link_prefix ): \"\"\" Returns a URL for `m`, which must be an instance of `Module`. Also, `m` must be a submodule of the module being documented. Namely, '.' import separators are replaced with '/' URL separators. Also, packages are translated as directories containing `index.html` corresponding to the `__init__` module, while modules are translated as regular HTML files with an `.m.html` suffix. (Given default values of `pdoc.html_module_suffix` and `pdoc.html_package_name`.) \"\"\" if parent . name == m . name : return \"\" base = m . name . replace ( \".\" , \"/\" ) if len ( link_prefix ) == 0 : base = os . path . relpath ( base , parent . name . replace ( \".\" , \"/\" )) url = base [ len ( \"../\" ) :] if base . startswith ( \"../\" ) else \"\" if base == \"..\" else base if m . submodules : index = pdocs . render . html_package_name url = url + \"/\" + index if url else index else : url += pdocs . render . html_module_suffix return link_prefix + url sourceid def ( dobj ) View Source def sourceid ( dobj ) : return \" source-%s \" % dobj . refname","title":"Html Helpers"},{"location":"reference/pdocs/html_helpers/#module-pdocshtml_helpers","text":"View Source import os import re import sys import markdown import pygments import pygments . formatters import pygments . lexers import pdocs . doc import pdocs . render from pdocs import defaults # From language reference , but adds '.' to allow fully qualified names . pyident = re . compile ( r \"^[a-zA-Z_][a-zA-Z0-9_.]+$\" ) indent = re . compile ( r \"^\\s*\" ) _ markdown = markdown . Markdown ( output_format= \"html5\" , extensions = defaults . MARKDOWN_EXTENSIONS , extension_configs = defaults . MARKDOWN_EXTENSION_CONFIGS , ) def _ markdown_render ( text ) : return _ markdown . reset (). convert ( text ) def decode ( s ) : if sys . version_info [ 0 ] < 3 and isinstance ( s , str ) : return s . decode ( \"utf-8\" , \"ignore\" ) return s def ident ( s ) : return '<span class=\"ident\">%s</span>' % s def sourceid ( dobj ) : return \"source-%s\" % dobj.refname def clean_source_lines ( lines ) : \"\"\" Cleans the source code so that pygments can render it well. Returns one string with all of the source code. \"\"\" base_indent = len ( indent . match ( lines [ 0 ]). group ( 0 )) base_indent = 0 for line in lines : if len ( line . strip ()) > 0 : base_indent = len ( indent . match ( lines [ 0 ]). group ( 0 )) break lines = [ line [ base_indent: ] for line in lines ] if sys . version_info [ 0 ] < 3 : pylex = pygments . lexers . PythonLexer () else : pylex = pygments . lexers . Python3Lexer () htmlform = pygments . formatters . HtmlFormatter ( cssclass= \"codehilite\" ) return pygments . highlight ( \"\" . join ( lines ), pylex , htmlform ) def linkify ( parent , match , link_prefix ) : matched = match . group ( 0 ) ident = matched [ 1 :- 1 ] name , url = lookup ( parent , ident , link_prefix ) if name is None : return matched return \"[`%s`](%s)\" % (name, url) def mark ( text , module_list = None , linky = True ) : if linky : text , _ = re . subn ( \"\\b\\n\\b\" , \" \" , text ) return _ markdown_render ( text . strip ()) def glimpse ( s , length = 100 ) : if len ( s ) < length : return s return s [ 0 :length ] + \"...\" def module_url ( parent , m , link_prefix ) : \"\"\" Returns a URL for `m`, which must be an instance of `Module`. Also, `m` must be a submodule of the module being documented. Namely, '.' import separators are replaced with '/' URL separators. Also, packages are translated as directories containing `index.html` corresponding to the `__init__` module, while modules are translated as regular HTML files with an `.m.html` suffix. (Given default values of `pdoc.html_module_suffix` and `pdoc.html_package_name`.) \"\"\" if parent . name == m . name : return \"\" base = m . name . replace ( \".\" , \"/\" ) if len ( link_prefix ) == 0 : base = os . path . relpath ( base , parent . name . replace ( \".\" , \"/\" )) url = base [ len ( \"../\" ) : ] if base . startswith ( \"../\" ) else \"\" if base == \"..\" else base if m . submodules : index = pdocs . render . html_package_name url = url + \"/\" + index if url else index else : url += pdocs . render . html_module_suffix return link_prefix + url def external_url ( refname ) : \"\"\" Attempts to guess an absolute URL for the external identifier given. Note that this just returns the refname with an \" . ext \" suffix. It will be up to whatever is interpreting the URLs to map it to an appropriate documentation page. \"\"\" return \"/%s.ext\" % refname def is_external_linkable ( name ) : return pyident . match ( name ) and \".\" in name def lookup ( module , refname , link_prefix ) : \"\"\" Given a fully qualified identifier name, return its refname with respect to the current module and a value for a `href` attribute. If `refname` is not in the public interface of this module or its submodules, then `None` is returned for both return values. (Unless this module has enabled external linking.) In particular, this takes into account sub-modules and external identifiers. If `refname` is in the public API of the current module, then a local anchor link is given. If `refname` is in the public API of a sub-module, then a link to a different page with the appropriate anchor is given. Otherwise, `refname` is considered external and no link is used. \"\"\" d = module . find_ident ( refname ) if isinstance ( d , pdocs . doc . External ) : if is_external_linkable ( refname ) : return d . refname , external_url ( d . refname ) else : return None , None if isinstance ( d , pdocs . doc . Module ) : return d . refname , module_url ( module , d , link_prefix ) if module . is_public ( d . refname ) : return d . name , \"#%s\" % d.refname return d . refname , \"%s#%s\" % (module_url(module, d.module, link_prefix), d.refname) def link ( parent , refname , link_prefix ) : \"\"\" A convenience wrapper around `href` to produce the full `a` tag if `refname` is found. Otherwise, plain text of `refname` is returned. \"\"\" name , url = lookup ( parent , refname , link_prefix ) if name is None : return refname return '<a href=\"%s\">%s</a>' % (url, name)","title":"Module pdocs.html_helpers"},{"location":"reference/pdocs/html_helpers/#variables","text":"indent pyident","title":"Variables"},{"location":"reference/pdocs/html_helpers/#functions","text":"","title":"Functions"},{"location":"reference/pdocs/html_helpers/#clean_source_lines","text":"def ( lines ) Cleans the source code so that pygments can render it well. Returns one string with all of the source code. View Source def clean_source_lines ( lines ) : \"\"\" Cleans the source code so that pygments can render it well . Returns one string with all of the source code . \"\"\" base_indent = len ( indent . match ( lines [ 0 ] ) . group ( 0 )) base_indent = 0 for line in lines : if len ( line . strip ()) > 0 : base_indent = len ( indent . match ( lines [ 0 ] ) . group ( 0 )) break lines = [ line [ base_indent :] for line in lines ] if sys . version_info [ 0 ] < 3 : pylex = pygments . lexers . PythonLexer () else : pylex = pygments . lexers . Python3Lexer () htmlform = pygments . formatters . HtmlFormatter ( cssclass = \" codehilite \" ) return pygments . highlight ( \"\" . join ( lines ) , pylex , htmlform )","title":"clean_source_lines"},{"location":"reference/pdocs/html_helpers/#decode","text":"def ( s ) View Source def decode ( s ) : if sys . version_info [ 0 ] < 3 and isinstance ( s , str ) : return s . decode ( \" utf-8 \" , \" ignore \" ) return s","title":"decode"},{"location":"reference/pdocs/html_helpers/#external_url","text":"def ( refname ) Attempts to guess an absolute URL for the external identifier given. Note that this just returns the refname with an \".ext\" suffix. It will be up to whatever is interpreting the URLs to map it to an appropriate documentation page. View Source def external_url ( refname ) : \"\"\" Attempts to guess an absolute URL for the external identifier given . Note that this just returns the refname with an \" .ext \" suffix . It will be up to whatever is interpreting the URLs to map it to an appropriate documentation page . \"\"\" return \" /%s.ext \" % refname","title":"external_url"},{"location":"reference/pdocs/html_helpers/#glimpse","text":"def ( s , length = 100 ) View Source def glimpse ( s , length = 100 ) : if len ( s ) < length : return s return s [ 0 : length ] + \" ... \"","title":"glimpse"},{"location":"reference/pdocs/html_helpers/#ident","text":"def ( s ) View Source def ident ( s ) : return ' <span class=\"ident\">%s</span> ' % s","title":"ident"},{"location":"reference/pdocs/html_helpers/#is_external_linkable","text":"def ( name ) View Source def is_external_linkable ( name ) : return pyident . match ( name ) and \" . \" in name","title":"is_external_linkable"},{"location":"reference/pdocs/html_helpers/#link","text":"def ( parent , refname , link_prefix ) A convenience wrapper around href to produce the full a tag if refname is found. Otherwise, plain text of refname is returned. View Source def link ( parent , refname , link_prefix ) : \"\"\" A convenience wrapper around ` href ` to produce the full ` a ` tag if ` refname ` is found . Otherwise , plain text of ` refname ` is returned . \"\"\" name , url = lookup ( parent , refname , link_prefix ) if name is None : return refname return ' <a href=\"%s\">%s</a> ' % ( url , name )","title":"link"},{"location":"reference/pdocs/html_helpers/#linkify","text":"def ( parent , match , link_prefix ) View Source def linkify ( parent , match , link_prefix ) : matched = match . group ( 0 ) ident = matched [ 1 :- 1 ] name , url = lookup ( parent , ident , link_prefix ) if name is None : return matched return \"[`%s`](%s)\" % (name, url)","title":"linkify"},{"location":"reference/pdocs/html_helpers/#lookup","text":"def ( module , refname , link_prefix ) Given a fully qualified identifier name, return its refname with respect to the current module and a value for a href attribute. If refname is not in the public interface of this module or its submodules, then None is returned for both return values. (Unless this module has enabled external linking.) In particular, this takes into account sub-modules and external identifiers. If refname is in the public API of the current module, then a local anchor link is given. If refname is in the public API of a sub-module, then a link to a different page with the appropriate anchor is given. Otherwise, refname is considered external and no link is used. View Source def lookup ( module , refname , link_prefix ) : \"\"\" Given a fully qualified identifier name , return its refname with respect to the current module and a value for a ` href ` attribute . If ` refname ` is not in the public interface of this module or its submodules , then ` None ` is returned for both return values . ( Unless this module has enabled external linking . ) In particular , this takes into account sub - modules and external identifiers . If ` refname ` is in the public API of the current module , then a local anchor link is given . If ` refname ` is in the public API of a sub - module , then a link to a different page with the appropriate anchor is given . Otherwise , ` refname ` is considered external and no link is used . \"\"\" d = module . find_ident ( refname ) if isinstance ( d , pdocs . doc . External ) : if is_external_linkable ( refname ) : return d . refname , external_url ( d . refname ) else : return None , None if isinstance ( d , pdocs . doc . Module ) : return d . refname , module_url ( module , d , link_prefix ) if module . is_public ( d . refname ) : return d . name , \" #%s \" % d . refname return d . refname , \" %s#%s \" % ( module_url ( module , d . module , link_prefix ) , d . refname )","title":"lookup"},{"location":"reference/pdocs/html_helpers/#mark","text":"def ( text , module_list = None , linky = True ) View Source def mark ( text , module_list = None , linky = True ) : if linky : text , _ = re . subn ( \" \\b \\n \\b \" , \" \" , text ) return _markdown_render ( text . strip ())","title":"mark"},{"location":"reference/pdocs/html_helpers/#module_url","text":"def ( parent , m , link_prefix ) Returns a URL for m , which must be an instance of Module . Also, m must be a submodule of the module being documented. Namely, '.' import separators are replaced with '/' URL separators. Also, packages are translated as directories containing index.html corresponding to the __init__ module, while modules are translated as regular HTML files with an .m.html suffix. (Given default values of pdoc.html_module_suffix and pdoc.html_package_name .) View Source def module_url ( parent , m , link_prefix ): \"\"\" Returns a URL for `m`, which must be an instance of `Module`. Also, `m` must be a submodule of the module being documented. Namely, '.' import separators are replaced with '/' URL separators. Also, packages are translated as directories containing `index.html` corresponding to the `__init__` module, while modules are translated as regular HTML files with an `.m.html` suffix. (Given default values of `pdoc.html_module_suffix` and `pdoc.html_package_name`.) \"\"\" if parent . name == m . name : return \"\" base = m . name . replace ( \".\" , \"/\" ) if len ( link_prefix ) == 0 : base = os . path . relpath ( base , parent . name . replace ( \".\" , \"/\" )) url = base [ len ( \"../\" ) :] if base . startswith ( \"../\" ) else \"\" if base == \"..\" else base if m . submodules : index = pdocs . render . html_package_name url = url + \"/\" + index if url else index else : url += pdocs . render . html_module_suffix return link_prefix + url","title":"module_url"},{"location":"reference/pdocs/html_helpers/#sourceid","text":"def ( dobj ) View Source def sourceid ( dobj ) : return \" source-%s \" % dobj . refname","title":"sourceid"},{"location":"reference/pdocs/logo/","text":"Module pdocs.logo 88 88 88 8 b , dPPYba , , adPPYb , 88 , adPPYba , , adPPYba , , adPPYba , 88 P ' \"8a a8\" `Y88 a8\" \"8a a8\" \"\" I8[ \"\" 88 d8 8 b 88 8 b d8 8 b ` \"Y8ba, 88 b , , a8 \" \" 8 a , , d88 \"8a, ,a8\" \"8a, ,aa aa ]8I 88 `YbbdP\"' ` \"8bbdP\" Y8 `\"YbbdP\"' ` \"Ybbd8\" ' `\"YbbdP\"' 88 88 - Documentation Powered by Your Python Code - Version : 0.1 . 3 Copyright Timothy Edmund Crosley 2019 MIT License View Source from pdocs._version import __version__ ascii_art = rf \"\"\" 88 88 88 8b,dPPYba, ,adPPYb,88 ,adPPYba, ,adPPYba, ,adPPYba, 88P' \"8a a8\" `Y88 a8\" \"8a a8\" \"\" I8[ \"\" 88 d8 8b 88 8b d8 8b `\"Y8ba, 88b, ,a8\" \"8a, ,d88 \"8a, ,a8\" \"8a, ,aa aa ]8I 88`YbbdP\"' `\"8bbdP\"Y8 `\"YbbdP\"' `\"Ybbd8\"' `\"YbbdP\"' 88 88 - Documentation Powered by Your Python Code - Version: {__version__} Copyright Timothy Edmund Crosley 2019 MIT License \"\"\" __doc__ = f \"\"\" ```python {ascii_art} ``` \"\"\" Variables ascii_art","title":"Logo"},{"location":"reference/pdocs/logo/#module-pdocslogo","text":"88 88 88 8 b , dPPYba , , adPPYb , 88 , adPPYba , , adPPYba , , adPPYba , 88 P ' \"8a a8\" `Y88 a8\" \"8a a8\" \"\" I8[ \"\" 88 d8 8 b 88 8 b d8 8 b ` \"Y8ba, 88 b , , a8 \" \" 8 a , , d88 \"8a, ,a8\" \"8a, ,aa aa ]8I 88 `YbbdP\"' ` \"8bbdP\" Y8 `\"YbbdP\"' ` \"Ybbd8\" ' `\"YbbdP\"' 88 88 - Documentation Powered by Your Python Code - Version : 0.1 . 3 Copyright Timothy Edmund Crosley 2019 MIT License View Source from pdocs._version import __version__ ascii_art = rf \"\"\" 88 88 88 8b,dPPYba, ,adPPYb,88 ,adPPYba, ,adPPYba, ,adPPYba, 88P' \"8a a8\" `Y88 a8\" \"8a a8\" \"\" I8[ \"\" 88 d8 8b 88 8b d8 8b `\"Y8ba, 88b, ,a8\" \"8a, ,d88 \"8a, ,a8\" \"8a, ,aa aa ]8I 88`YbbdP\"' `\"8bbdP\"Y8 `\"YbbdP\"' `\"Ybbd8\"' `\"YbbdP\"' 88 88 - Documentation Powered by Your Python Code - Version: {__version__} Copyright Timothy Edmund Crosley 2019 MIT License \"\"\" __doc__ = f \"\"\" ```python {ascii_art} ``` \"\"\"","title":"Module pdocs.logo"},{"location":"reference/pdocs/logo/#variables","text":"ascii_art","title":"Variables"},{"location":"reference/pdocs/render/","text":"Module pdocs.render View Source import os.path import re import typing from mako.exceptions import TopLevelLookupException from mako.lookup import TemplateLookup import pdocs.doc html_module_suffix = \".html\" html_package_name = \"index.html\" \"\"\" The file name to use for a package's `__init__.py` module. \"\"\" _template_path = [ os . path . join ( os . path . dirname ( __file__ ), \"templates\" )] \"\"\" A list of paths to search for Mako templates used to produce the plain text and HTML output. Each path is tried until a template is found. \"\"\" tpl_lookup = TemplateLookup ( directories = _template_path , cache_args = { \"cached\" : True , \"cache_type\" : \"memory\" } ) \"\"\" A `mako.lookup.TemplateLookup` object that knows how to load templates from the file system. You may add additional paths by modifying the object's `directories` attribute. \"\"\" def _get_tpl ( name ): \"\"\" Returns the Mako template with the given name. If the template cannot be found, a nicer error message is displayed. \"\"\" try : t = tpl_lookup . get_template ( name ) except TopLevelLookupException : locs = [ os . path . join ( p , name . lstrip ( \"/\" )) for p in _template_path ] raise IOError ( 2 , \"No template at any of: %s \" % \", \" . join ( locs )) return t def html_index ( roots : typing . Sequence [ pdocs . doc . Module ], link_prefix : str = \"/\" ) -> str : \"\"\" Render an HTML module index. \"\"\" t = _get_tpl ( \"/html_index.mako\" ) t = t . render ( roots = roots , link_prefix = link_prefix ) return t . strip () def html_module ( mod : pdocs . doc . Module , external_links : bool = False , link_prefix : str = \"/\" , source : bool = True ) -> str : \"\"\" Returns the documentation for the module `module_name` in HTML format. The module must be importable. If `external_links` is `True`, then identifiers to external modules are always turned into links. If `link_prefix` is `True`, then all links will have that prefix. Otherwise, links are always relative. If `source` is `True`, then source code will be retrieved for every Python object whenever possible. This can dramatically decrease performance when documenting large modules. \"\"\" t = _get_tpl ( \"/html_module.mako\" ) t = t . render ( module = mod , external_links = external_links , link_prefix = link_prefix , show_source_code = source ) return t . strip () def text ( mod : pdocs . doc . Module , source : bool = True ) -> str : \"\"\"Returns the documentation for the module `module_name` in plain text format. The module must be importable. *source* - If set to True (the default) source will be included in the produced output. \"\"\" t = _get_tpl ( \"/text.mako\" ) text , _ = re . subn ( \" \\n\\n\\n +\" , \" \\n\\n \" , t . render ( module = mod , show_source_code = source ) . strip ()) return text Variables html_module_suffix html_package_name The file name to use for a package's __init__.py module. tpl_lookup A mako.lookup.TemplateLookup object that knows how to load templates from the file system. You may add additional paths by modifying the object's directories attribute. Functions html_index def ( roots : Sequence [ pdocs . doc . Module ], link_prefix : str = '/' ) -> str Render an HTML module index. View Source def html_index ( roots : typing . Sequence [ pdocs . doc . Module ], link_prefix : str = \" / \" ) -> str : \"\"\" Render an HTML module index . \"\"\" t = _get_tpl ( \" /html_index.mako \" ) t = t . render ( roots = roots , link_prefix = link_prefix ) return t . strip () html_module def ( mod : pdocs . doc . Module , external_links : bool = False , link_prefix : str = '/' , source : bool = True ) -> str Returns the documentation for the module module_name in HTML format. The module must be importable. If external_links is True , then identifiers to external modules are always turned into links. If link_prefix is True , then all links will have that prefix. Otherwise, links are always relative. If source is True , then source code will be retrieved for every Python object whenever possible. This can dramatically decrease performance when documenting large modules. View Source def html_module ( mod : pdocs . doc . Module , external_links : bool = False , link_prefix : str = \" / \" , source : bool = True ) -> str : \"\"\" Returns the documentation for the module ` module_name ` in HTML format . The module must be importable . If ` external_links ` is ` True `, then identifiers to external modules are always turned into links . If ` link_prefix ` is ` True `, then all links will have that prefix . Otherwise , links are always relative . If ` source ` is ` True `, then source code will be retrieved for every Python object whenever possible . This can dramatically decrease performance when documenting large modules . \"\"\" t = _get_tpl ( \" /html_module.mako \" ) t = t . render ( module = mod , external_links = external_links , link_prefix = link_prefix , show_source_code = source ) return t . strip () text def ( mod : pdocs . doc . Module , source : bool = True ) -> str Returns the documentation for the module module_name in plain text format. The module must be importable. source - If set to True (the default) source will be included in the produced output. View Source def text ( mod : pdocs . doc . Module , source : bool = True ) -> str : \"\"\" Returns the documentation for the module `module_name` in plain text format . The module must be importable . * source * - If set to True ( the default ) source will be included in the produced output . \"\"\" t = _get_tpl ( \" /text.mako \" ) text , _ = re . subn ( \" \\n\\n\\n + \" , \" \\n\\n \" , t . render ( module = mod , show_source_code = source ) . strip ()) return text","title":"Render"},{"location":"reference/pdocs/render/#module-pdocsrender","text":"View Source import os.path import re import typing from mako.exceptions import TopLevelLookupException from mako.lookup import TemplateLookup import pdocs.doc html_module_suffix = \".html\" html_package_name = \"index.html\" \"\"\" The file name to use for a package's `__init__.py` module. \"\"\" _template_path = [ os . path . join ( os . path . dirname ( __file__ ), \"templates\" )] \"\"\" A list of paths to search for Mako templates used to produce the plain text and HTML output. Each path is tried until a template is found. \"\"\" tpl_lookup = TemplateLookup ( directories = _template_path , cache_args = { \"cached\" : True , \"cache_type\" : \"memory\" } ) \"\"\" A `mako.lookup.TemplateLookup` object that knows how to load templates from the file system. You may add additional paths by modifying the object's `directories` attribute. \"\"\" def _get_tpl ( name ): \"\"\" Returns the Mako template with the given name. If the template cannot be found, a nicer error message is displayed. \"\"\" try : t = tpl_lookup . get_template ( name ) except TopLevelLookupException : locs = [ os . path . join ( p , name . lstrip ( \"/\" )) for p in _template_path ] raise IOError ( 2 , \"No template at any of: %s \" % \", \" . join ( locs )) return t def html_index ( roots : typing . Sequence [ pdocs . doc . Module ], link_prefix : str = \"/\" ) -> str : \"\"\" Render an HTML module index. \"\"\" t = _get_tpl ( \"/html_index.mako\" ) t = t . render ( roots = roots , link_prefix = link_prefix ) return t . strip () def html_module ( mod : pdocs . doc . Module , external_links : bool = False , link_prefix : str = \"/\" , source : bool = True ) -> str : \"\"\" Returns the documentation for the module `module_name` in HTML format. The module must be importable. If `external_links` is `True`, then identifiers to external modules are always turned into links. If `link_prefix` is `True`, then all links will have that prefix. Otherwise, links are always relative. If `source` is `True`, then source code will be retrieved for every Python object whenever possible. This can dramatically decrease performance when documenting large modules. \"\"\" t = _get_tpl ( \"/html_module.mako\" ) t = t . render ( module = mod , external_links = external_links , link_prefix = link_prefix , show_source_code = source ) return t . strip () def text ( mod : pdocs . doc . Module , source : bool = True ) -> str : \"\"\"Returns the documentation for the module `module_name` in plain text format. The module must be importable. *source* - If set to True (the default) source will be included in the produced output. \"\"\" t = _get_tpl ( \"/text.mako\" ) text , _ = re . subn ( \" \\n\\n\\n +\" , \" \\n\\n \" , t . render ( module = mod , show_source_code = source ) . strip ()) return text","title":"Module pdocs.render"},{"location":"reference/pdocs/render/#variables","text":"html_module_suffix html_package_name The file name to use for a package's __init__.py module. tpl_lookup A mako.lookup.TemplateLookup object that knows how to load templates from the file system. You may add additional paths by modifying the object's directories attribute.","title":"Variables"},{"location":"reference/pdocs/render/#functions","text":"","title":"Functions"},{"location":"reference/pdocs/render/#html_index","text":"def ( roots : Sequence [ pdocs . doc . Module ], link_prefix : str = '/' ) -> str Render an HTML module index. View Source def html_index ( roots : typing . Sequence [ pdocs . doc . Module ], link_prefix : str = \" / \" ) -> str : \"\"\" Render an HTML module index . \"\"\" t = _get_tpl ( \" /html_index.mako \" ) t = t . render ( roots = roots , link_prefix = link_prefix ) return t . strip ()","title":"html_index"},{"location":"reference/pdocs/render/#html_module","text":"def ( mod : pdocs . doc . Module , external_links : bool = False , link_prefix : str = '/' , source : bool = True ) -> str Returns the documentation for the module module_name in HTML format. The module must be importable. If external_links is True , then identifiers to external modules are always turned into links. If link_prefix is True , then all links will have that prefix. Otherwise, links are always relative. If source is True , then source code will be retrieved for every Python object whenever possible. This can dramatically decrease performance when documenting large modules. View Source def html_module ( mod : pdocs . doc . Module , external_links : bool = False , link_prefix : str = \" / \" , source : bool = True ) -> str : \"\"\" Returns the documentation for the module ` module_name ` in HTML format . The module must be importable . If ` external_links ` is ` True `, then identifiers to external modules are always turned into links . If ` link_prefix ` is ` True `, then all links will have that prefix . Otherwise , links are always relative . If ` source ` is ` True `, then source code will be retrieved for every Python object whenever possible . This can dramatically decrease performance when documenting large modules . \"\"\" t = _get_tpl ( \" /html_module.mako \" ) t = t . render ( module = mod , external_links = external_links , link_prefix = link_prefix , show_source_code = source ) return t . strip ()","title":"html_module"},{"location":"reference/pdocs/render/#text","text":"def ( mod : pdocs . doc . Module , source : bool = True ) -> str Returns the documentation for the module module_name in plain text format. The module must be importable. source - If set to True (the default) source will be included in the produced output. View Source def text ( mod : pdocs . doc . Module , source : bool = True ) -> str : \"\"\" Returns the documentation for the module `module_name` in plain text format . The module must be importable . * source * - If set to True ( the default ) source will be included in the produced output . \"\"\" t = _get_tpl ( \" /text.mako \" ) text , _ = re . subn ( \" \\n\\n\\n + \" , \" \\n\\n \" , t . render ( module = mod , show_source_code = source ) . strip ()) return text","title":"text"},{"location":"reference/pdocs/static/","text":"Module pdocs.static View Source import pathlib import typing import pdocs . doc import pdocs . render class StaticError ( Exception ) : pass def module_to_path ( m : pdocs . doc . Module , extension= \"html\" ) -> pathlib . Path : \"\"\" Calculates the filesystem path for the static output of a given module. \"\"\" p = pathlib . Path ( * m . name . split ( \".\" )) if m . submodules : p /= f \"index.{extension}\" else : p = p . with_suffix ( f \".{extension}\" ) return p def path_to_module ( roots : typing . Sequence [ pdocs . doc . Module ], path : pathlib . Path ) -> pdocs . doc . Module : \"\"\" Retrieves the matching module for a given path from a module tree. \"\"\" if path . suffix == \".html\" : path = path . with_suffix ( \"\" ) parts = list ( path . parts ) if parts [ - 1 ] == \"index\" : parts = parts [:- 1 ] elif parts [ - 1 ] == \"index.m\" : parts [ - 1 ] = \"index\" for root in roots : mod = root . find_ident ( \".\" . join ( parts )) if isinstance ( mod , pdocs . doc . Module ) : return mod raise StaticError ( \"No matching module for {path}\" . format ( path = path )) def would_overwrite ( destination : pathlib . Path , roots : typing . Sequence [ pdocs . doc . Module ]) -> bool : \"\"\"Would rendering root to dst overwrite any file?\"\"\" if len ( roots ) > 1 : path = destination / \"index.html\" if path . exists () : return True for root in roots : if destination . joinpath ( root . name ). exists () : return True return False def html_out ( dst : pathlib . Path , roots : typing . Sequence [ pdocs . doc . Module ], external_links: bool = True , link_prefix: str = \"\" , source : bool = False , ) : if len ( roots ) > 1 : dst . mkdir ( parents = True , exist_ok = True ) p = dst / \"index.html\" idx = pdocs . render . html_index ( roots , link_prefix = link_prefix ) p . write_text ( idx , encoding= \"utf-8\" ) for root in roots : for m in root . allmodules () : p = dst . joinpath ( module_to_path ( m )) p . parent . mkdir ( parents = True , exist_ok = True ) out = pdocs . render . html_module ( m , external_links = external_links , link_prefix = link_prefix , source = source ) p . write_text ( out , encoding= \"utf-8\" ) def md_out ( dst : pathlib . Path , roots : typing . Sequence [ pdocs . doc . Module ], externel_links: bool = True , source : bool = False , ) : for root in roots : for m in root . allmodules () : p = dst . joinpath ( module_to_path ( m , extension= \"md\" )) p . parent . mkdir ( parents = True , exist_ok = True ) out = pdocs . render . text ( m , source = source ) p . write_text ( out , encoding= \"utf-8\" ) Functions html_out def ( dst : pathlib . Path , roots : Sequence [ pdocs . doc . Module ], external_links : bool = True , link_prefix : str = '' , source : bool = False ) View Source def html_out ( dst : pathlib . Path , roots : typing . Sequence [ pdocs . doc . Module ], external_links : bool = True , link_prefix : str = \"\" , source : bool = False , ) : if len ( roots ) > 1 : dst . mkdir ( parents = True , exist_ok = True ) p = dst / \" index.html \" idx = pdocs . render . html_index ( roots , link_prefix = link_prefix ) p . write_text ( idx , encoding = \" utf-8 \" ) for root in roots : for m in root . allmodules () : p = dst . joinpath ( module_to_path ( m )) p . parent . mkdir ( parents = True , exist_ok = True ) out = pdocs . render . html_module ( m , external_links = external_links , link_prefix = link_prefix , source = source ) p . write_text ( out , encoding = \" utf-8 \" ) md_out def ( dst : pathlib . Path , roots : Sequence [ pdocs . doc . Module ], externel_links : bool = True , source : bool = False ) View Source def md_out ( dst : pathlib . Path , roots : typing . Sequence [ pdocs . doc . Module ], externel_links : bool = True , source : bool = False , ) : for root in roots : for m in root . allmodules () : p = dst . joinpath ( module_to_path ( m , extension = \" md \" )) p . parent . mkdir ( parents = True , exist_ok = True ) out = pdocs . render . text ( m , source = source ) p . write_text ( out , encoding = \" utf-8 \" ) module_to_path def ( m : pdocs . doc . Module , extension = 'html' ) -> pathlib . Path Calculates the filesystem path for the static output of a given module. View Source def module_to_path ( m : pdocs . doc . Module , extension = \" html \" ) -> pathlib . Path : \"\"\" Calculates the filesystem path for the static output of a given module . \"\"\" p = pathlib . Path ( * m . name . split ( \" . \" )) if m . submodules : p /= f \" index.{extension} \" else : p = p . with_suffix ( f \" .{extension} \" ) return p path_to_module def ( roots : Sequence [ pdocs . doc . Module ], path : pathlib . Path ) -> pdocs . doc . Module Retrieves the matching module for a given path from a module tree. View Source def path_to_module ( roots : typing . Sequence [ pdocs . doc . Module ], path : pathlib . Path ) -> pdocs . doc . Module : \"\"\" Retrieves the matching module for a given path from a module tree. \"\"\" if path . suffix == \".html\" : path = path . with_suffix ( \"\" ) parts = list ( path . parts ) if parts [ - 1 ] == \"index\" : parts = parts [:- 1 ] elif parts [ - 1 ] == \"index.m\" : parts [ - 1 ] = \"index\" for root in roots : mod = root . find_ident ( \".\" . join ( parts )) if isinstance ( mod , pdocs . doc . Module ) : return mod raise StaticError ( \"No matching module for {path}\" . format ( path = path )) would_overwrite def ( destination : pathlib . Path , roots : Sequence [ pdocs . doc . Module ] ) -> bool Would rendering root to dst overwrite any file? View Source def would_overwrite ( destination : pathlib . Path , roots : typing . Sequence [ pdocs . doc . Module ] ) -> bool : \"\"\" Would rendering root to dst overwrite any file? \"\"\" if len ( roots ) > 1 : path = destination / \" index.html \" if path . exists () : return True for root in roots : if destination . joinpath ( root . name ) . exists () : return True return False Classes StaticError class ( / , * args , ** kwargs ) Common base class for all non-exit exceptions. View Source class StaticError ( Exception ): pass Ancestors (in MRO) builtins.Exception builtins.BaseException Class variables args Methods with_traceback def ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"Static"},{"location":"reference/pdocs/static/#module-pdocsstatic","text":"View Source import pathlib import typing import pdocs . doc import pdocs . render class StaticError ( Exception ) : pass def module_to_path ( m : pdocs . doc . Module , extension= \"html\" ) -> pathlib . Path : \"\"\" Calculates the filesystem path for the static output of a given module. \"\"\" p = pathlib . Path ( * m . name . split ( \".\" )) if m . submodules : p /= f \"index.{extension}\" else : p = p . with_suffix ( f \".{extension}\" ) return p def path_to_module ( roots : typing . Sequence [ pdocs . doc . Module ], path : pathlib . Path ) -> pdocs . doc . Module : \"\"\" Retrieves the matching module for a given path from a module tree. \"\"\" if path . suffix == \".html\" : path = path . with_suffix ( \"\" ) parts = list ( path . parts ) if parts [ - 1 ] == \"index\" : parts = parts [:- 1 ] elif parts [ - 1 ] == \"index.m\" : parts [ - 1 ] = \"index\" for root in roots : mod = root . find_ident ( \".\" . join ( parts )) if isinstance ( mod , pdocs . doc . Module ) : return mod raise StaticError ( \"No matching module for {path}\" . format ( path = path )) def would_overwrite ( destination : pathlib . Path , roots : typing . Sequence [ pdocs . doc . Module ]) -> bool : \"\"\"Would rendering root to dst overwrite any file?\"\"\" if len ( roots ) > 1 : path = destination / \"index.html\" if path . exists () : return True for root in roots : if destination . joinpath ( root . name ). exists () : return True return False def html_out ( dst : pathlib . Path , roots : typing . Sequence [ pdocs . doc . Module ], external_links: bool = True , link_prefix: str = \"\" , source : bool = False , ) : if len ( roots ) > 1 : dst . mkdir ( parents = True , exist_ok = True ) p = dst / \"index.html\" idx = pdocs . render . html_index ( roots , link_prefix = link_prefix ) p . write_text ( idx , encoding= \"utf-8\" ) for root in roots : for m in root . allmodules () : p = dst . joinpath ( module_to_path ( m )) p . parent . mkdir ( parents = True , exist_ok = True ) out = pdocs . render . html_module ( m , external_links = external_links , link_prefix = link_prefix , source = source ) p . write_text ( out , encoding= \"utf-8\" ) def md_out ( dst : pathlib . Path , roots : typing . Sequence [ pdocs . doc . Module ], externel_links: bool = True , source : bool = False , ) : for root in roots : for m in root . allmodules () : p = dst . joinpath ( module_to_path ( m , extension= \"md\" )) p . parent . mkdir ( parents = True , exist_ok = True ) out = pdocs . render . text ( m , source = source ) p . write_text ( out , encoding= \"utf-8\" )","title":"Module pdocs.static"},{"location":"reference/pdocs/static/#functions","text":"","title":"Functions"},{"location":"reference/pdocs/static/#html_out","text":"def ( dst : pathlib . Path , roots : Sequence [ pdocs . doc . Module ], external_links : bool = True , link_prefix : str = '' , source : bool = False ) View Source def html_out ( dst : pathlib . Path , roots : typing . Sequence [ pdocs . doc . Module ], external_links : bool = True , link_prefix : str = \"\" , source : bool = False , ) : if len ( roots ) > 1 : dst . mkdir ( parents = True , exist_ok = True ) p = dst / \" index.html \" idx = pdocs . render . html_index ( roots , link_prefix = link_prefix ) p . write_text ( idx , encoding = \" utf-8 \" ) for root in roots : for m in root . allmodules () : p = dst . joinpath ( module_to_path ( m )) p . parent . mkdir ( parents = True , exist_ok = True ) out = pdocs . render . html_module ( m , external_links = external_links , link_prefix = link_prefix , source = source ) p . write_text ( out , encoding = \" utf-8 \" )","title":"html_out"},{"location":"reference/pdocs/static/#md_out","text":"def ( dst : pathlib . Path , roots : Sequence [ pdocs . doc . Module ], externel_links : bool = True , source : bool = False ) View Source def md_out ( dst : pathlib . Path , roots : typing . Sequence [ pdocs . doc . Module ], externel_links : bool = True , source : bool = False , ) : for root in roots : for m in root . allmodules () : p = dst . joinpath ( module_to_path ( m , extension = \" md \" )) p . parent . mkdir ( parents = True , exist_ok = True ) out = pdocs . render . text ( m , source = source ) p . write_text ( out , encoding = \" utf-8 \" )","title":"md_out"},{"location":"reference/pdocs/static/#module_to_path","text":"def ( m : pdocs . doc . Module , extension = 'html' ) -> pathlib . Path Calculates the filesystem path for the static output of a given module. View Source def module_to_path ( m : pdocs . doc . Module , extension = \" html \" ) -> pathlib . Path : \"\"\" Calculates the filesystem path for the static output of a given module . \"\"\" p = pathlib . Path ( * m . name . split ( \" . \" )) if m . submodules : p /= f \" index.{extension} \" else : p = p . with_suffix ( f \" .{extension} \" ) return p","title":"module_to_path"},{"location":"reference/pdocs/static/#path_to_module","text":"def ( roots : Sequence [ pdocs . doc . Module ], path : pathlib . Path ) -> pdocs . doc . Module Retrieves the matching module for a given path from a module tree. View Source def path_to_module ( roots : typing . Sequence [ pdocs . doc . Module ], path : pathlib . Path ) -> pdocs . doc . Module : \"\"\" Retrieves the matching module for a given path from a module tree. \"\"\" if path . suffix == \".html\" : path = path . with_suffix ( \"\" ) parts = list ( path . parts ) if parts [ - 1 ] == \"index\" : parts = parts [:- 1 ] elif parts [ - 1 ] == \"index.m\" : parts [ - 1 ] = \"index\" for root in roots : mod = root . find_ident ( \".\" . join ( parts )) if isinstance ( mod , pdocs . doc . Module ) : return mod raise StaticError ( \"No matching module for {path}\" . format ( path = path ))","title":"path_to_module"},{"location":"reference/pdocs/static/#would_overwrite","text":"def ( destination : pathlib . Path , roots : Sequence [ pdocs . doc . Module ] ) -> bool Would rendering root to dst overwrite any file? View Source def would_overwrite ( destination : pathlib . Path , roots : typing . Sequence [ pdocs . doc . Module ] ) -> bool : \"\"\" Would rendering root to dst overwrite any file? \"\"\" if len ( roots ) > 1 : path = destination / \" index.html \" if path . exists () : return True for root in roots : if destination . joinpath ( root . name ) . exists () : return True return False","title":"would_overwrite"},{"location":"reference/pdocs/static/#classes","text":"","title":"Classes"},{"location":"reference/pdocs/static/#staticerror","text":"class ( / , * args , ** kwargs ) Common base class for all non-exit exceptions. View Source class StaticError ( Exception ): pass","title":"StaticError"},{"location":"reference/pdocs/static/#ancestors-in-mro","text":"builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/pdocs/static/#class-variables","text":"args","title":"Class variables"},{"location":"reference/pdocs/static/#methods","text":"","title":"Methods"},{"location":"reference/pdocs/static/#with_traceback","text":"def ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"}]}